%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Постановка задачи}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Сформулируем требования к системе вывода типов для динамически
типизированного языка, являющейся частью статического анализа, осуществляемого
средой разработки.

\begin{enumerate}
    \item{Высокая точность анализа}
    \item{Высокое быстродействие}
    \item{Совместимость с существующей функциональностью среды разработки}
\end{enumerate}

\section{Точность анализа}
\label{sec:precision-requirement}

Как уже обсуждалось в первой главе, системы типов и процедуры проверки типов
(\emph{typechecker}), встроенные в компиляторы статически типизированных
языков, являются консервативными (\emph{conservative}), а их задачей является
доказательство отсутствия в программе определенного класса ошибок. Следствием
этого является то, что иногда неверно типизированной (\emph{ill-typed})
считается программа, которая в действительности не имеет ошибок времени
исполнения. Такие ошибки системы типов, называемые в западной литературе
ложноотрицательными \emph{false-negative}, а отечественной --- ошибками второго
рода, являются проявлением того такого свойства систем типов как неполнота
(\emph{incompleteness}). 

Понятия \emph{точности} (\emph{soundness}) и \emph{полноты}
(\emph{completeness}) происходят из математической логики. Несколько неформально
их можно определить следующим образом: если имеется некоторая реальная система
(программа), которая описывается упрощенной моделью (системой типов), то, если
любое свойство, доказанное в модели (отсутствие ошибок, корректность),
справедливо и в системе, то модель \emph{точна} (\emph{sound}).  Если же,
наоборот, любое свойство системы, справедливо и в модели, то модель \emph{полна}
(\emph{complete}).

Также можно встретить такое определение этих
понятий\footnote{\url{http://math.stackexchange.com/questions/105575/what-is-the-difference-between-completeness-and-soundness-in-first-order-logic}}:

\begin{quote}
``Точность'' означает, что нельзя доказать то, что неверно (soundness means that
you cannot prove anything that's wrong).

``Полнота'' означает, что можно доказать все, что верно (completeness means that
you can prove anything that's right).
\end{quote}

Будучи точными (\emph{sound}), но неполными (\emph{incomplete}) алгоритмы
проверки типов в компиляторах статически типизированных языков не
могут принять, иначе говоря, доказать корректность, содержащей ошибку (\emph{ill-behaved})
программы, но не обязательно должны допустить корректную.

Прежде чем сформулировать свойства полноты и точности применительно к
статическому анализу, важно отметить, что обе характеристики зависят от того,
что именно мы пытаемся доказать.

В статическом анализе, в частности в том, что осуществляется в IDE, ставится
противоположная задача --- доказать \emph{наличие в программе определенных
  ошибок}.  Следовательно, точный статический анализ, не допускающий ошибок
ошибок первого рода, не должен приводить к ложным сообщениям об ошибках в программе, в
то время как полный --- не должен пропустить ни одну из них. Поскольку
статический анализ не связан с безопасностью самого языка (\emph{language
  safety}), на котором написана программа, а является лишь дополнительной
предосторожностью при разработке, его неполнота, приводящая к тому, что
некоторые ошибки в программе будут не найдены, является допустимой. В то же
время неточность анализа, из-за которой пользователю будут выдаваться
предупреждения о несуществующих дефектах в программе, является значительно более
серьезным недостатком, особенно в IDE, где такой анализ может происходить
непрерывно.

Еще раз сформулируем свойство точности статического анализа:

\emph{Точный статический анализ не должен приводить к ложным сообщениям об 
ошибках.}

Здесь важно сделать еще одно замечание. Статический анализ, не способный
обнаружить ни одну ошибку в программе, также считается абсолютно точным. Поэтому
на практике мы стремимся к максимально точному анализу при по возможности
наибольшей полноте.

\section{Быстродействие}
\label{sec:performance-requirement}

Быстродействие анализа является важной характеристикой для среды разработки, так
как для сохранения точности результатов анализ может запускаться
при каждом изменении файла с исходным текстом программы. Одним из путей
достижения быстродействия является построение индексов, которые представляют
собой плоские базы данных типа ключ-значение. В индексах может храниться такая
информация, как место определения класса или функции по их имени или,
например, все файлы в которых встречалось определенное слово, а также
сериализованные фрагменты синтаксических деревьев (AST) модулей программы. Индексы
позволяют избежать частого проведения синтаксического анализа, однако само
построение индексов для проекта является длительной операцией, поэтому одним из
важнейших свойств статического анализа, осуществляемого в IDE является его
\emph{инкрементальность}.

\nomenclature{AST}{Abstract Syntax Tree}

\emph{Инкрементальный статический анализ не должен приводить к индексации 
 каких-либо модулей проекта помимо редактируемого.}

Данное условие существенно ограничивает спектр возможных алгоритмов, отбрасывая
в частности те из них, которые для вывода типов требуют анализа всего проекта. Из
 изученных публикаций только две~\cite{Pluquet2009,Haupt2011} упоминают
использование алгоритмов вывода типов в контексте среды разработки. И лишь
первая из них предлагает быстрый (но неточный) алгоритм для статического вывода типов.

\section{Совместимость с существующей функциональностью среды разработки}
\label{sec:compatibility-requirement}

Поскольку разрабатываемый алгоритм для вывода типов предназначен, в первую
очередь, для использования в среде разработки PyCharm, естественно, что он должен
быть совместим с имеющейся функциональностью IDE и платформы, на базе которой
разработан PyCharm. В том числе с существующими механизмами по выводу типов в
программах на Python. 

На данный момент в PyCharm уже используются практически все описанные в разделе
\ref{sec:type-sources} пути получения информации о типах, а именно:

\begin{enumerate}
    \item Литералы и конструкторы.

    \item Опциональные аннотации в Python
      3\footnote{\url{http://legacy.python.org/dev/peps/pep-3107/}}, а также
      аннотации типов в документации в форматах Sphinx и Epydoc. Причем поскольку в
      Python отсутствует общепринятый формат записи сложных типов, например,
      типов-пересечений или типов параметризованных коллекций, в PyCharm
      определен свой собственный.
      В таких аннотациях в том числе можно использовать абстрактные базовые
      классы модуля !collections.abc!, например, !Sized! или !Hashable!.

    \item Условные проверки типов при помощи стандартной функции !isinstance!.

    \item Информация о типах стандартных функций и методов, полученная из
        модулей-заглушек
        (\emph{skeletons})\footnote{\url{https://github.com/JetBrains/python-skeletons}}.
        Также имеется возможность добавления пользовательских описаний
        интерфейсов для сторонних библиотек.

    \item Типы передаваемых аргументов в местах использования функции.

    \item Значения аргументов функций по-умолчанию и возвращаемые из функции
        значения.

    \item Информация о типах, собранная динамически во время отладки.
\end{enumerate}

Кроме того, в отличие от практически всех рассмотренных публикаций анализ в
PyCharm является чувствительным к потоку управления(\emph{flow-sensitive}), и 
учитывает поток управления всех конструкций языка, а также псевдонимы
переменных (\emph{aliases}). Для описания полиморфизма данных в PyCharm
используются типы-объединения. 


