%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Постановка задачи}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Сразу сформулируем требования к системе вывода типов для динамически
типизированного языка, являющейся частью статического анализа, осуществляемого
средой разработки.

\begin{enumerate}
    \item{Точность анализа}
    \item{Быстродействие}
    \item{Совместимость с существующей функциональностью среды разработки}
\end{enumerate}

\section{Точность анализа}

Как уже обсуждалось в первой главе, системы типов и процедуры проверки типов
являются \emph{консервативными}, а их задачей является доказательство
\emph{отсутствия в программе определенного класса ошибок}.  Следствием этого
является то, что иногда неверно типизированной (\emph{ill-typed}) считается
программа, которая в действительности не имеет ошибок времени исполнения. Такие
ошибки системы типов, называемые в западной литературе false-negative, а
отечественной --- ошибками второго рода, являются проявлением того такого
свойства систем типов как неполнота (\emph{incompleteness}). 

Понятия точности и \emph{полноты} (\emph{completeness}) пришли из математики. Несколько
неформально их можно определить следующим образом. Если имеется некоторая
реальная система (программа), которая описывается упрощенной моделью (системой
типов), то, если любое свойство, доказанное в модели (отсутствие ошибок,
корректность), справедливо и в системе, то модель \emph(точна) (\emph{sound}).
Если же, наоборот, любое свойство системы, справедливо и в модели, то модель
\emph{полна} (\emph{complete}).

Также можно встретить такое определение этих
понятий\footnote{\url{http://math.stackexchange.com/questions/105575/what-is-the-difference-between-completeness-and-soundness-in-first-order-logic}}:

\begin{quote}
Soundness means that you cannot prove anything that's wrong (``Точность'' означает,
что нельзя доказать то, что неверно).

Completeness means that you can prove anything that's right (``Полнота'' означает,
что можно доказать то, что верно).
\end{quote}

Будучи точными (sound), но неполными (incomplete) алгоритмы проверки типов
(typechecker) в компиляторах статически типизированных языков не могут
пропустить, т.е. доказать корректность, некорректной (ill-behaved) программы, но
не обязательно должны допустить корректную.

Прежде чем сформулировать свойства полноты и точности применительно к
статическому анализу, важно отметить, что обе характеристики зависят от того,
что именно мы пытаемся доказать.

В статическом анализе, в частности в том, что осуществляется в IDE, ставится
противоположная задача --- доказать \emph{наличие в программе определенных
  ошибок}.  Следовательно, точный статический анализ, не допускающий ошибок
второго рода, не должен приводить к ложным сообщениям об ошибках в программе, в
то время как полный --- не должен пропустить ни одну из них. Поскольку
статический анализ, не связан с безопасностью самого языка (\emph{language
  safety}), на котором написана программа, а является лишь дополнительной
предосторожностью при разработке, его неполнота, приводящая к тому, что
некоторые ошибки в программе будут не найдены, является допустимой. В то же
время неточность анализа, из-за которой пользователю будут выдаваться
предупреждения о ненастоящих ошибках, является более серьезным недостатком.

Еще раз сформулируем свойство точности статического анализа:

\emph{Точный статический анализ не должен приводить к ложным сообщениям об 
ошибках}

\section{Быстродействие}

Быстродействие является критической характеристикой среды разработки, так как
потенциально для сохранения точности результатов анализ может запускаться при
каждом изменении файла с исходным текстом программы. Одним из путей достижения
быстродействия является построение индексов, которые представляют собой плоские
базы данных типа ключ-значение. В индексах может храниться такая информация, как
место определения класса или функции, по их имени, или, например, все файлы в
которых встречалось определенное слово. Построение индексов для всего проекта
является длительной операцией, поэтому одним из важнейших свойств статического
анализа, осуществляемого в IDE является его \emph{инкрементальность}.

\emph{Инкрементальный статический анализ не должен приводить к индексации 
 каких-либо модулей проекта помимо редактируемого.}

Данное условие существенно ограничивает спектр возможных алгоритмов, отбрасывая
в частности те из них, которые для вывода типов требую анализа всего проекта. Из
 изученных публикаций только две~\cite{Pluquet2009,Haupt2011} упоминают
использование алгоритмов вывода типов в контексте среды разработки. И лишь
первая из них предлагает быстрый (но неточный) алгоритм для статического вывода типов.

\section{Совместимость с существующей функциональностью среды разработки}

Поскольку разрабатываемый алгоритм для вывода типов предназначен в первую
очередь для использования в среде разработки PyCharm, естественно что он должен
быть совместим с имеющейся функциональностью IDE и платформы, на базе которой
она разработана. В с существующими механизмами по выводу типов в проектах на
Python. 

Одной из сложностей, возникших при написании данной работы, было то, что в
PyCharm уже используются практически все описанные в разделе
\ref{sec:type-sources} способы. На данный момент для анализа уже используются:

\begin{enumerate}
    \item{%
        Литералы и конструкторы.
      }
    \item{%
        Опциональные аннотации в Python 3, а также извлеченные из
        документации. Причем поскольку в Python отсутствует общепринятый формат
        записи сложных типов, например, типов-пересечений или типов
        параметризованных коллекций, поэтому в PyCharm определен свой собственный.
        В таких аннотациях в том числе можно использовать абстрактные базовые
        классы модуля !collections.abc!, например, !Sized! или !Hashable!.
    }
    \item{%
        Условные проверки типов при помощи стандартной функции !isinstance()!.
      }
    \item{%
        Информация о типах стандартных функций и методов, полученная из
        модулей-заглушек
        (skeletons)\footnote{\url{https://github.com/JetBrains/python-skeletons}}.
        Также имеется возможность добавления пользовательских описаний
        интерфейсов для сторонних библиотек.
      }
    \item{%
        Типы аргументов в местах вызова функций.
      }
    \item{%
        Значения аргументов функций по-умолчанию и возвращаемые из функции
        значения.
      }
    \item{%
        Информация о типах, собранная во время отладки.
      }
\end{enumerate}

Кроме того, в отличие от практически всех рассмотренных публикаций анализ в PyCharm
является flow-sensitive, т.е. учитывает поток управления всех конструкций языка
и алиасинг имен. Таким образом, не только обеспечение совместимости с имеющимися
средствами, но даже поиск того, что еще может быть добавлено имеет
определенную сложность. 

После изучения работы вывода типов в PyCharm было решено сосредоточится на
проблеме выводе типов параметров функций, поскольку на именно в этих случаях
информации о типах выводимой PyCharm оказывается недостаточно.

