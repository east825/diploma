%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Постановка задачи}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Сразу сформулируем требования к системе вывода типов для динамически
типизированного языка, являющейся частью статического анализа, осуществляемого
средой разработки.

\begin{enumerate}
    \item{Точность анализа}
    \item{Быстродействие}
    \item{Совместимость с существующей функциональностью среды разработки}
\end{enumerate}

\section{Точность анализа}
\label{sec:precision-requirement}

Как уже обсуждалось в первой главе, системы типов и процедуры проверки типов
являются консервативными (\emph{conservative}), а их задачей является
доказательство отсутствия в программе определенного класса ошибок. Следствием
этого является то, что иногда неверно типизированной (\emph{ill-typed})
считается программа, которая в действительности не имеет ошибок времени
исполнения. Такие ошибки системы типов, называемые в западной литературе
false-negative, а отечественной --- ошибками второго рода, являются проявлением
того такого свойства систем типов как неполнота (\emph{incompleteness}). 

Понятия \emph{точности} (\emph{soundness}) и \emph{полноты}
(\emph{completeness}) происходят из математической логики. Несколько неформально
их можно определить следующим образом: если имеется некоторая реальная система
(программа), которая описывается упрощенной моделью (системой типов), то, если
любое свойство, доказанное в модели (отсутствие ошибок, корректность),
справедливо и в системе, то модель \emph(точна) (\emph{sound}).  Если же,
наоборот, любое свойство системы, справедливо и в модели, то модель \emph{полна}
(\emph{complete}).

Также можно встретить такое определение этих
понятий\footnote{\url{http://math.stackexchange.com/questions/105575/what-is-the-difference-between-completeness-and-soundness-in-first-order-logic}}:

\begin{quote}
``Точность'' означает, что нельзя доказать то, что неверно (soundness means that
you cannot prove anything that's wrong).

``Полнота'' означает, что можно доказать все, что верно (completeness means that
you can prove anything that's right).
\end{quote}

Будучи точными (\emph{sound}), но неполными (\emph{incomplete}) алгоритмы
проверки типов (typechecker) в компиляторах статически типизированных языков не
могут пропустить, т.е. доказать корректность, некорректной (\emph{ill-behaved})
программы, но не обязательно должны допустить корректную.

Прежде чем сформулировать свойства полноты и точности применительно к
статическому анализу, важно отметить, что обе характеристики зависят от того,
что именно мы пытаемся доказать.

В статическом анализе, в частности в том, что осуществляется в IDE, ставится
противоположная задача --- доказать \emph{наличие в программе определенных
  ошибок}.  Следовательно, точный статический анализ, не допускающий ошибок
второго рода, не должен приводить к ложным сообщениям об ошибках в программе, в
то время как полный --- не должен пропустить ни одну из них. Поскольку
статический анализ, не связан с безопасностью самого языка (\emph{language
  safety}), на котором написана программа, а является лишь дополнительной
предосторожностью при разработке, его неполнота, приводящая к тому, что
некоторые ошибки в программе будут не найдены, является допустимой. В то же
время неточность анализа, из-за которой пользователю будут выдаваться
предупреждения о ненастоящих ошибках, является более серьезным недостатком.

Еще раз сформулируем свойство точности статического анализа:

\emph{Точный статический анализ не должен приводить к ложным сообщениям об 
ошибках.}

\section{Быстродействие}
\label{sec:performance-requirement}

Быстродействие является критической характеристикой среды разработки, так как
потенциально для сохранения точности результатов анализ может запускаться при
каждом изменении файла с исходным текстом программы. Одним из путей достижения
быстродействия является построение индексов, которые представляют собой плоские
базы данных типа ключ-значение. В индексах может храниться такая информация, как
место определения класса или функции, по их имени, или, например, все файлы в
которых встречалось определенное слово. Построение индексов для всего проекта
является длительной операцией, поэтому одним из важнейших свойств статического
анализа, осуществляемого в IDE является его \emph{инкрементальность}.

\emph{Инкрементальный статический анализ не должен приводить к индексации 
 каких-либо модулей проекта помимо редактируемого.}

Данное условие существенно ограничивает спектр возможных алгоритмов, отбрасывая
в частности те из них, которые для вывода типов требую анализа всего проекта. Из
 изученных публикаций только две~\cite{Pluquet2009,Haupt2011} упоминают
использование алгоритмов вывода типов в контексте среды разработки. И лишь
первая из них предлагает быстрый (но неточный) алгоритм для статического вывода типов.

\section{Совместимость с существующей функциональностью среды разработки}
\label{sec:compatibility-requirement}

Поскольку разрабатываемый алгоритм для вывода типов предназначен в первую
очередь для использования в среде разработки PyCharm, естественно что он должен
быть совместим с имеющейся функциональностью IDE и платформы, на базе которой
она разработана. В том числе с существующими механизмами по выводу типов в
программах на Python. 

На данный момент в PyCharm уже используются практически все описанные в разделе
\ref{sec:type-sources} пути получения информации о типах, а именно:

\begin{enumerate}
    \item Литералы и конструкторы.

    \item Опциональные аннотации в Python
      3\footnote{\url{http://legacy.python.org/dev/peps/pep-3107/}}, а также
      аннотации типов в документации в форматах Sphinx и Epydoc. Причем поскольку в
      Python отсутствует общепринятый формат записи сложных типов, например,
      типов-пересечений или типов параметризованных коллекций, в PyCharm
      определен свой собственный.
      В таких аннотациях в том числе можно использовать абстрактные базовые
      классы модуля !collections.abc!, например, !Sized! или !Hashable!.

    \item Условные проверки типов при помощи стандартной функции !isinstance()!.

    \item Информация о типах стандартных функций и методов, полученная из
        модулей-заглушек
        (\emph{skeletons})\footnote{\url{https://github.com/JetBrains/python-skeletons}}.
        Также имеется возможность добавления пользовательских описаний
        интерфейсов для сторонних библиотек.

    \item Типы аргументов в местах вызова функции для вывода ее типа.

    \item Значения аргументов функций по-умолчанию и возвращаемые из функции
        значения.

    \item Информация о типах, собранная динамически во время отладки.
\end{enumerate}

Кроме того, в отличие от практически всех рассмотренных публикаций анализ в
PyCharm является flow-sensitive, т.е. учитывает поток управления всех
конструкций языка, а также псевдонимы имен (\emph{aliases}). Для описания полиморфизма
данных в PyCharm используются типы-объединения. 


