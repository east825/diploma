%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор предметной области}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Системы типов и динамическая типизация}

Динамически типизированными называются языки, в которых проверки типов
происходят во время исполнения программы (\emph{runtime}). Одно из
распространенных определений, принадлежащее Guy Steel, звучит как:

\begin{quote}
  A dynamic language is one that defers as many decisions as possible to
  runtime.
\end{quote}

Интересно, что несмотря на распространенность выражения, ряд специалистов,
например, B. Pierce~\cite{Pierce2002}, считают такой термин неточным, предлагая
использовать использовать глагол \emph{check} для обозначения проверок,
происходящих во время исполнения программы~\cite{Cardelli2004}, т.е.
\emph{dynamically checked language}.

% Динамически типизированные языки имеют долгую историю в Computer Science. Так
% один из первых языков, использующих динамическую типизацию --- Lisp --- появился
% в 1958 году, т.е. примерно в то же время, что и первый компилятор Fortran.

Здесь и далее мы принимаем за \emph{тип} верхнюю границу множества возможных
значений выражения в программе~\cite{Cardelli2004}, например, только !True! или
!False! для значения типа !bool! или целое число в диапазоне 
$[-2^{31}, 2^{31}-1]$ для значения типа !int!.

Статически типизированные языки, с другой стороны, не исключая проверок во время
исполнения, ставят задачу выяснить как можно больше информации о программе
статически, для чего в них применяются формальные методы из теорий статического
анализа и систем типов (\emph{type systems}). 

B. Pierce определяет систему типов как:

\begin{quote}
  A type system is a tractable syntactic method for proving the absence of certain
  program behaviors by classifying phrases according to the kinds of values they
  compute.
\end{quote}

Детали используемой системы типов традиционно являются частью спецификации языка
и оказывают непосредственное влияние на его семантику. Как следствие, ошибки,
допущенные при проектировании системы типов может быть практически невозможно
исправить без разрушения обратной совместимости с существующим приложениями.

% Retrofitting a type system onto a language not designed with typechecking
% in mind can be tricky; ideally, language design should go hand-in-hand with
% type system design.
% One reason for this is that languages without type systems—even safe, dy-
% namically checked languages—tend to offer features or encourage program-
% ming idioms that make typechecking difficult or infeasible. Indeed, in typed
% languages the type system itself is often taken as the foundation of the de-
% sign and the organizing principle in light of which every other aspect of the
% design is considered.

Полученная информация может быть использована как для выполнения компилятором
определенных оптимизаций над программой, так и для предотвращения определенного
класса ошибок до ее исполнения (\emph{execution errors}~\cite{Cardelli2004},
\emph{run-time type errors}~\cite{Pierce2002}). Можно сказать, что системы типов
являются одним из самых широко распространенных средств обеспечения качества ПО.
Для программиста результатом таких проверок является то, что определенные
программы могут быть отвергнуты компилятором или линковщиком как содержащие
ошибку типов, или некорректно типизированные(\emph{ill-typed}).
Такая ошибка может заключаться, например, в присвоении значения несовместимого
типа переменной в программе или в обращении к несуществующему методу в программе
на Java, так и свидетельствовать о более сложных нарушениях в программе в
зависимости от выразительности языка и его системы типов. Принятая 
программа, с другой стороны, считается корректно типизированной (\emph{well
  typed}), что в свою очередь означает, что программа является правильной
(\emph{well-behaved}), т.е. не содержит ошибок, которые призвана исключить
система типов. 

Для того гарантировать последнее свойство, системы типов являются 
консервативными: факт того, что программа прошла проверку означает, что
она \emph{не содержит} ошибку, однако обратное не гарантируется, то есть
корректная программа может быть расценена как ошибочная.  Простым примером
такого поведения является ошибка типа в недостижимом участке программы,
например, в ветви условного оператора, которая никогда не выполняется. 

Также для обеспечения работы механизма проверки типов на практике большинство
применяемых сегодня систем типов требуют содействия со стороны программиста в
первую очередь через внесение им в программу аннотаций типов (\emph{type
  annotations}). Количество таких аннотаций, тем не менее, может сильно
варьироваться в конкретных языках: от практически тотального аннотирования
программ на Java до отдельных аннотаций в местах неоднозначности в Haskell и
других функциональных языках семейства ML. Последние используют алгоритмы вывода
типов (\emph{type inference}), позволяющие опустить значительную часть аннотаций
путем вывода типов из контекста, в котором используется выражение.  
L.~Cardelli~\cite{Cardelli2004} называет языки, синтаксис которых включает
аннотации типов, явно типизированными (\emph{explicitly typed}), и неявно
типизированными (\emph{implicitly typed}) в обратном случае.

Также отмечается~\cite{Pierce2002}, что система типов работает наиболее
эффективно, когда программист в полной мере использует ее возможности, в
частности по определению новых пользовательских типов, более точно описывающих
предметную область приложения и, как следствие, задающих большее число ограничений
которые могут быть проверены статически.

% Например, для программы на Java, все сложные
% структуры данных которой выражаются через стандартные коллекции, такие как
% !ArrayList! или !HashMap!, компилятор не сможет найти значительную часть ошибок
% вроде сохранения значения неправильного типа. 

Вышеописанные требования, иногда воспринимающиеся как искусственно ``навязанные''
программисту системой типов, зачастую перегруженный аннотациями синтаксис языка,
а также то, что большинство \emph{логических ошибок} в программе, таких как, например,
выход за пределы массива или деление на ноль, обнаружить статически все равно не
удается --- все это, во-первых, побуждает исследователей разрабатывать более
сложные и выразительные систем типов, во-вторых, способствует широкому
применению языков с динамической типизацией, которые лишены этих проблем.

В отсутствие статических проверок, предоставляемых системой типов, для
обеспечения качества ПО при разработке на динамически типизированных языках
применяются другие методы, главным из которых является обширное модульное
тестирование. Также получили распространение динамические проверки, позволяющие
обнаружить ошибки типов как можно раньше во время исполнения программы, в том
числе методы, основанные на использовании контрактного программирования, а также
различные пакетные (\emph{batch-}) статические анализаторы. Последние обычно
включают в себя процесс разрешения типов выражений, однако из-за ряда
особенностей, присущих динамически типизированным языкам и описываемых далее в
этой главе, известные алгоритмы, применяющиеся в статически типизированных
языках, оказываются либо крайне неэффективными либо, либо вовсе неприменимыми.

Среды разработки (IDE) позволяют наиболее тесно интегрировать статический анализ
для поиска ошибок в процесс написания программ, однако, будучи
интерактивными инструментами непосредственно взаимодействующими с пользователем
сильно зависят от времени анализа, а также от точности его результатов и поэтому
часто не могут использовать даже тех алгоритмов, которые используются в пакетных
статических анализаторах. Между тем, точный вывод типов положительно бы сказался
и на другой функциональности IDE, например, автодополнении, навигации по проекту
или проведении автоматических рефакторингов.

\nomenclature{IDE}{Integrated Development Environment}

\section{Сложности вывода типов в динамически типизированных языках}
\label{sec:difficulties}

Прежде чем перейти к рассмотрению существующих решений, перечислим некоторые
особенности динамически типизированных языков, делающие точный вывод типов в них
сложной проблемой.

\subsection{Неограниченный полиморфизм данных}

Способность переменной хранить значение одного из нескольких типов называется
полиморфизмом данных (\emph{data polymorphism})~\cite{Agesen1995}. 

\begin{quote}
  Data polymorphism is the ability to store objects of different types in a
  variable or slot. 
\end{quote}

Системы типов статически типизированных языков обычно ограничивают множество
возможных типов.  Например, в объектно-ориентированных статически типизированных
языках, таких как Java переменная не примитивного типа может хранить либо
значение того типа с которым она объявлена, либо одного из его подклассов, либо
универсальное значение !null!, а в функциональных языках таких как SML
переменная алгебраического типа данных (\emph{algebraic data type}) может
хранить значение одного из его конструкторов.

Однако при динамической типизации полиморфизм данных ничем не
сдерживается. Например, функция в некоторых случаях может возвращать
единственное значение некоторого типа, а в других --- список. В Ruby,
например, существует практика возвращать из функции !false!, чтобы указать на
отсутствие значения~\cite{Ren2013}. 

Естественно, что такое поведение функции делает понимание поведения программы в
целом (\emph{reasoning}) более сложным, и, как правило, такие случаи
должны быть должным образом задокументированы. 

Частным случаем такой формы полиморфизма данных является использование
\emph{гетерогенных} (\emph{heterogeneous}) коллекций. В статически
типизированных языках изменяемые коллекции \emph{гомогенны}
(\emph{homogeneous}), т.е. состоят из элементов одинаковых типов, или по крайней
мере имеющих общего предка в иерархии типов. Так как статически неизвестно, как
эта коллекция может измениться во время исполнения программы, такое ограничение
гарантирует, что система типов не пропустит случая обращения к конкретному
элементу через неверный интерфейс. Даже если коллекция никогда не изменяется, а
программист точно знает, какие типы имеют отдельные элементы, ему потребуется
явная операция приведения типов (\emph{downcast}) для того, чтобы компилятор
допустил обращение к элементам как к конкретным типам. Например, следующий
фрагмент программы не будет пропущен компилятором !javac!:

\begin{lstlisting}[language=Java]
Arrays.asList(42, "foo", null).get(1).toUpperCase();
\end{lstlisting}

Однако использование оператора приведения типа позволит успешно скомпилировать
программу:

\begin{lstlisting}[language=Java]
((String) Arrays.asList(42, "foo", null).get(1)).toUpperCase()
\end{lstlisting}

Языки с динамической типизацией не имеют таких ограничений и следующая программа
на Python выполнится без каких-либо дополнительных действий со стороны
программиста:

\begin{lstlisting}
print([42, 'foo', None][1].upper())
\end{lstlisting}

Применение подобных возможностей конструкций в программе вынуждает вводить в
алгоритмы вывода типов специальные типы, одними из которых являются
\emph{типы-пересечения} (\emph{union-types}).  Например, в следующем примере типом
переменной !x! будет считаться !str|int!.

\begin{lstlisting}
if random() > 0.5:
    x = 'foo'
else:
    x = 42
print(x.upper())
\end{lstlisting}

Однако использование подобных типов поднимает ряд вопросов о точности такого
анализа. Например, считать ли вызов к !x.upper()! в последней
строке ошибочным или доверится разработчику? Считать ли что у значения
!x! есть методы и класса !str!, и класса !int!, или же только общие, например,
перегруженные операторы сравнения?

Интересный подход с использованием двух специальных видов типов-пересечений:
динамических, включающих атрибуты всех входящих в них классов, и статических,
содержащих только атрибуты общие для всех классов-элементов, описан в
работе~\cite{Ortin2011:union} применительно к исследовательскому языку StaDyn,
компилирующемуся в байт-код .NET, и использующем появившийся в .NET 4.0 Dynamic
Language Runtime (DLR).

\nomenclature{DLR}{Dynamic Language Runtime}

В работе~\cite{Igarashi2006} обсуждается возможность использования
типов-пересечений в системе типов языка Featherweight Java. В качестве одного из
сценариев их использования предлагается их применение для обеспечения
совместимости со сторонними библиотеками, где введение нового абстрактного
базового класса или интерфейса невозможно.  

В публикации M. Salib~\cite{Salib2004} рассматриваются некоторые аспекты анализа
типов коллекций в Python, в том числе проблема определения того, когда
выведенная ранее (например, из литерала) информация о типе элементов коллекции
становится неточной. Для этого, например, с каждым списком в программе ассоциирован
специальный флаг, указывающий на то был ли список ``испорчен'' (\emph{tainted})
операцией, которая может сделать ранее выведенную информацию о типах отдельных
элементов неверной, например, вызовом метода !sort()!. Пока флаг сброшен и имеется
информация о типах конкретных элементов, используется эта информация, но после
выставления флага тип каждого элемента становится объединением известных типов.

\subsection{Метапрограммирование и динамические возможности}

Одной из характерных особенностей языков с динамической типизацией являются
значительно расширенные по сравнению со статически типизированными языками
возможности метапрограммирования. Причем речь идет не только о возможностях
интроспекции, то есть анализа программой себя самой, но о
структурном изменении существующих объектов, а также создании новых
в процессе исполнения. В качестве примеров можно привести, добавление новых
методов и полей как самим классам, так и конкретным их экземплярам, или
интерпретация содержимого строки как фрагмента программы --- возможности
недоступные или чрезвычайно трудоемкие для языков со статической типизацией.

В работе~\cite[]{Holkner2009} приводится обзор и классификация динамических
возможностей программ на Python, включающих в себя средства
метапрограммирования: 

\begin{itemize}
  \item{%
      Рефлексия (\emph{reflection}). 
      Использование мета-объектных возможностей языка, например,
      вызов метода или чтение атрибута объекта по его имени, получение
      информации о базовых классах класса, импортирование модуля по его имении
      пр. Следует отметить, что такие возможности не является уникальными для
      языков с динамической типизацией --- похожие механизмы имеются в языках с
      виртуальной машиной и управляемой памятью (\emph{managed languages}),
      например, Java и C\#.
    }
  \item{%
      Динамическая типизация (\emph{dynamic typing}). 
      В эту категорию авторы включают расширенный полиморфизм данных, описанный
      в предыдущем разделе, то есть факт того, что переменная имеет тип того
      значения, которое ей присвоено, и диапазон возможных значений не
      ограничен.
    }
  \item{%
      Динамические объекты (\emph{dynamic objects}).
      Сюда включаются возможность изменять структуру классов и объектов в
      программе: добавлять к ним новые методы и поля, а также удалять и добавлять
      существующие. Такая модификация ``живых'' объектов программы также часто
      называется \emph{monkey patching}.

      Здесь следует отметить, что возможности по изменению встроенных
      типов, например, базового класса object или стандартных коллекций, в Python, в
      отличие от, например, Ruby~\cite{Madsen2007}, невозможны без применения сторонних библиотек.
      % Часто упоминающаяся возможность изменять список базовых классов у уже
      % определенного класса, также не всегда допустима.
    }
  \item{  
      Динамический код (\emph{dynamic code}).
      В эту категорию авторы относят все стандартные средства для генерации и
      исполнения программы из исходных текстов во время ее исполнения.
      Например, функции !exec! и !eval! в Python, позволяют выполнить
      произвольный фрагмент программы, переданный им в виде строки.  Причем его
      источник может быть абсолютно произвольным: например, он может быть введен
      пользователем или получен через сеть.

      \begin{lstlisting}
      exec(input('Enter statement: '))  
      \end{lstlisting}

      Подобные функции имеются и в других динамически типизированных языках,
      например, в JavaScript и Ruby.

      Несмотря на то, что в некоторых случаях, использование возможности
      динамического конструирования и исполнения программы может заменить собой
      этап генерации, традиционно применяющийся в статически типизированных
      языках, в целом они не рекомендуются к применению, так как их
      использование не только затрудняет понимание программы, но и делает ее
      уязвимой.

    }
\end{itemize}

Интересно, что в ряде работ по выводу типов в динамически типизированных языках,
например~\cite{Salib2004,Aycock2000}, исследователи предполагают, что подобные
возможности языка используются достаточно редко, и поэтому их можно игнорировать
в процессе анализа.  Например, в~\cite{Aycock2000} J. Aycock пишет:

\begin{quote} Giving people a dynamically-typed language does not mean that they
  write dynamically typed programs. 
\end{quote}

Причем, если для анализа программ, использующих !exec! и !eval! не было найдено
ни одного эффективного решения, то пренебрежение такой часто используемой
возможностью, как присвоение значений несовместимых типов одной переменной,
естественно негативно сказывается на точности анализа. 

Для написания интерпретатора в проекте PyPy был даже создан диалект Python ---
RPython (Restricted Python)~\cite{Ancona2007}, который сохраняя привычный
синтаксис языка по своим возможностям в большей степени близок к Java: типы
переменных фиксированы, наследование от единственного суперкласса, а все
перечисленные средства метапрограммирования недоступны. 

Между тем, в уже упомянутой работе~\cite{Holkner2009} было проведено
исследование ряда существующих программ, где при помощи инструментированного
интерпретатора оценивалось, насколько часто используются подобные динамические
возможности в действительности. Их результаты показывают, что каждая из 24
рассмотренных в работе программ в той или иной мере использует динамические
возможности языка, и нередко замена таких участков на ``более статические''
эквиваленты оказывается нетривиальной. 


\subsection{``Утиная'' типизация (duck typing)}

Утиная типизация (\emph{duck typing}) является настолько характерной для
динамически типизированных языков, что иногда можно встретить использование
выражения ``duck-typed language'' в качестве синонима динамически
типизированного языка. Суть похода заключается в том, что для того, чтобы два
типа были совместимы не требуется какoе-либо формальное задание отношений между
ними, например, наличие общего предка в иерархии классов, как в Java, а лишь
совместимость их интерфейсов (здесь идет речь об интерфейсах в общем смысле ---
как о множестве доступных для обращения атрибутов объекта). При этом это полного
совпадения не требуется --- только тех атрибутов, которые реально используются.
В работе~\cite{Ortin2011:union} это свойство сформулировано таким образом:

\begin{quote}
    Duck typing is a property offered by most dynamically typed
    languages that means that an object is interchangeable with any other
    object that implements the same dynamic interface, regardless of whether
    those objects have a related inheritance hierarchy or not.
\end{quote}

Например, если мы хотим, чтобы некоторая функция принимала в качестве аргумента
значение некоторого типа, имеющего метод !draw!, не нужно специально выделять
суперкласс, содержащий этот метод, достаточно лишь, чтобы такой метод просто был
доступен для вызова. Если больше ни к каким атрибутам объекта обращение не
происходит, их имена и типы не играют роли. 

\begin{lstlisting}
class Cowboy:
    def draw(self):
        print('Drawing a gun')

class Pen:
    def draw(self):
        print('Drawing a line')

def draw_something(o):
    o.move()
\end{lstlisting}

Нередко в литературе можно встретить описание типов объектов в терминах
сообщений (\emph{messages}), которые они могут принять. Например, в Smalltalk
сообщения называются селекторами (\emph{selectors}), а объект, на них отвечающий, ---
приемником (\emph{receiver}). Сообщениями считаются вызовы методов и обращения к полям
объекта. В языках с ``утиной'' типизацией, конкретные классы не играют роли, так
как их имена фигурируют лишь при их объявлении, важно лишь, чтобы объект мог
ответить на необходимое сообщение.  

Интересно, что из-за ``утиной'' типизации наследование, которое в статически
типизированных объектно-ориентированных языка, таких как Java, является
одним из основных механизмом внесения полиморфизма в программу (так называемый
\emph{полиморфизм подтипов}, англ. \emph{subtyping polymorphism}),
в языках с динамической типизацией становится преимущественно средством
повторного использования кода. В частности уменьшается роль интерфейсов и
абстрактных классов, несмотря на то, что, например, в Python такие возможности
имеются. В качестве примера можно привести использование в
стандартной библиотеке Python так называемых протоколов. Например, класс, в
котором определен метод !__iter__! удовлетворяет протоколу
итерируемого объекта (\emph{Iterable}), что делает возможным его использование,
в циклах !for! и многих методах, работающих с коллекциями, 
Использования специального интерфейса !Iterable!, как в Java, не требуется.

Утиная типизация очень близка к понятию \emph{структурной эквивалентности}
(\emph{structural equivalence}) типов, которой противопоставляется \emph{номинальная
эквивалентность} (\emph{nominal equivalence}) типов (также используются понятия
номинальной и структурной систем типов).

Benjamin Pierce пишет про номинальные и структурные системы типов~\cite{Pierce2002}.

\begin{quote}
Type systems like Java’s, in which names are significant and subtyping is
explicitly declared, are called nominal. Type systems ... in which names are
inessential and subtyping is defined directly on the structures of types are
called structural.
\end{quote}

К преимуществами номинальных систем типов, помимо некоторых упрощений в
алгоритмах проверки типов и среды исполнения языка относят то,
что она не позволяет считать эквивалентными два типа идентичные структурно, но
описывающие различные принципиально несовместимые сущности в программе.
Например, если имеются два структурно эквивалентных типа !Point! и
!TextRange!, но у !TextRange! также имеется ограничение на
возможные значения полей !x! и !y!, передача объекта !Point! вместо
TextRange может привести к нарушению принятых инвариантов в программе.

\begin{lstlisting}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class TextRange:
    def __init__(self, x, y):
        if y < x or x < 0:
            raise ValueError('Illegal range: must be y >= x && x >= 0')
        self.x = x
        self.y = y
\end{lstlisting}

В то же время, к недостаткам номинальных систем типов относят сложность их
расширения: если на каком-то этапе потребуется обеспечить совместимость двух
классов не имеющих общего предка, единственный способ сделать это --- определить
и внести новый абстрактный класс или интерфейс, который они будут наследовать,
что не всегда возможно:

\begin{quote}
However, interfaces cannot be added once a class is defined, so library
designers still have to do a lot of planning of their interface hierarchies
before the library is shipped. This problem has been considered a significant
limitation of type systems with declaration-based subtyping, as in Java.
\end{quote}

Интересным расширением номинальной системы типов, позволяющим обойти это
ограничение, являются типы-объединения (\emph{union-types}), содержащие методы
общие для всех входящих в объединение классов. За подробных обсуждением этой
идеи рекомендуем обратиться к уже упоминавшейся работе~\cite[]{Igarashi2006}.

Структурные системы типов нашли свое место и в языках со статической
типизацией, например Go и OCaml~\cite[с.~33]{Ocaml}, а также в проекте
TypeScript~\cite[]{TypeScript} --- диалекте JavaScript с опциональной
типизацией. 

Приведенный ранее пример с методом !draw! выглядел бы в OCaml как

% language=[Dialect]Language cannot be used with lstlisting environment
% directly
\begin{lstlisting}[language={[Objective]Caml}]
class cowboy =
    object (self)
        method draw =
            print_string "Drawing a gun"
    end

class pen = 
    object (self) 
        method draw =
         print_string "Drawing a line"
    end

let draw_something o =
    o#draw

\end{lstlisting}

Функция в данном случае !draw_something! имеет следующий тип

\begin{lstlisting}
val draw_something : < draw : 'a; .. > -> 'a = <fun>
\end{lstlisting}

Более того, можно даже создать объект без ассоциированного с ним класса --- так
называемый \emph{immediate object} --- содержащий метод !draw!, его так
же можно будет передать в функцию !draw_something!.

\begin{lstlisting}
# let o = object
      method draw = print_string "draw called on immediate object"
  end;;

val o : < draw : unit > = <obj>
# draw_something o;;
draw called on immediate object- : unit = ()
\end{lstlisting}
\lstset{language=Python}

В работе~\cite{Ortin2011:union} описывается использование подобной техники
применительно к динамически типизированным вставкам в разработанном авторами
языке StaDyn, транслирующимся в программы на языке C\# с использованием
появившегося в C\# 4.0 ключевого слова !dynamic!.  Авторы называют такие
типы --- типами-пересечениями (\emph{intersection types}), представляя каждое
обращение к методу или полю объекта, как неявное определение нового типа. Тип,
объединяющий все такие элементарные типы, считается их пересечением.

В работе~\cite{Pluquet2009}, посвященной разработке быстрого алгоритма вывода
типов для Smalltalk, авторы называют такие структурные типы интерфейсными 
\emph{interface types}. После сбора информации о передаваемых объекту сообщениях,
происходит анализ иерархии известных системе классов в поисках наиболее
точного типа, имеющего необходимую сигнатуру. Такой алгоритм фактически
совмещает структурную и номинальную системы типов, сначала инерпретируя типы
объектов структурно для сбора наиболее точной информации, а затем пытаясь
представить их в более привычном для программиста виде --- через имена
конкретных классов.

\subsection{Типы функций}

Вывод точных типов функций в программах на динамически типизированных языках
представляет особенно сложную проблему. Если для локальных переменных обычно
оказывается возможным вывести информацию об их типах из контекста в котором они
были определены, например, через использование литерала одного из встроенных
типов или вызов конструктора (более подробно источники информации о типах
описаны в разделе \ref{sec:type-sources}), то для параметров функций в
отсутствии каких-либо аннотаций, единственными источниками информации о их
предполагаемых типах становятся, во-первых, использование значений параметров в
теле функции, например, ранее описанная передача им сообщений, во-вторых, типы
аргументов передаваемых в функцию при ее вызовах (\emph{call sites}).

Особую сложность представляют функции с параметрическим полиморфизмом, в
которых тип возвращаемого значения зависит от конкретных типов аргументов, 
потому что для таких функций информация о типах передаваемых аргументов не
является источником точной информации о возможных значениях параметров.
Простейшим примером такой функции является функция идентичности,
которая возвращает свой единственный аргумент.

\begin{lstlisting}
def id(x):
    return x
\end{lstlisting}

Одним из хорошо известных алгоритмов для решения проблемы точного вывода типов
функций с параметрическим полиморфизмом является Cartesian Product Algorithm, 
разработанный в 1995 году Ole Ageseen для языка SELF. 

\todo{Описать CPA}

\nomenclature{CPA}{Cartesian Product Algorithm}

% From a type inference perspective, Python is a large and complex language. In
% contrast to other languages that rely heavily on type inference for
% performance, such as Eiffel, Haskell, or the many variants of ML, Python was
% designed with little thought as to how the language semantics would hinder or
% help type inference. Instead, Python’s semantics evolved over several years in
% response to feedback from a community of skilled practitioners. Thus, while
% languages like Haskell suffer occasional design flaws that had to be imposed
% specifically to make type inference easier, Python makes no such compromises
% in its design, which only makes Starkiller’s job that much harder.

\subsection{Модули-расширения и стандартная библиотека}
\label{sec:extensions-and-stdlib}

Еще одним препятствием на пути точного вывода типов в динамически типизированных
языках является то, что с целью повышения быстродействия многие компоненты их
стандартных библиотек написаны написаны на С/C++, и распространяются в
виде скомпилированных динамических библиотек. Это же характерно и для сторонних
библиотек, предоставляющих API для работы с графикой, звуком или подключаемыми
устройствами.

Эта проблема, упоминаемая иногда как \emph{foreign code interaction}, означает, что даже при
наличии эффективного алгоритма для вывода типов самом динамически типизированном
языке, его не удастся применить к часто используемым функциям и классам
стандартной библиотеки. Для ее решения существует несколько подходов:

\begin{itemize}
    \item{%
        Получение информации о типах из документации.  Так, Python и Ruby
        используют специальные языки документации reStructuredText и RDoc,
        включающие в том числе специальные теги для описания типов принимаемых и
        возвращаемых значений функций. При условии, что стандартная библиотека и
        другие скомпилированные подключаемые модули должным образом
        документированы, эти данные можно извлечь и использовать в алгоритме
        вывода.  В частности так поступили авторы проекта Ecstatic для
        Ruby~\cite{Madsen2007}.  Этот же подход, впрочем, может быть использован
        и как дополнительный источник информации о типах и при анализе модулей
        на самом целевом языке.
      }
    \item{%
        Использование модулей-заглушек (\emph{skeletons}). Идея заключается в
        написании или генерации специальных модулей на целевом языке, которые
        имитируют интерфейсы стандартной или сторонней библиотеки,
        из которых могут быть выведены типы при помощи имеющегося алгоритма.
        Например, так поступили авторы нескольких работ, посвященных
        выводу типов в Python~\cite{Aycock2000,Salib2004}.  Так,
        стандартная функция !abs()! в Python, возвращающая модуль числа,
        описывается в~\cite{Aycock2000} при помощи такой заглушки:

        \begin{lstlisting}
def abs(N):
    N = 123
    return N
        \end{lstlisting}

        Такие модули-заглушки, могут также включать и документирующие
        комментарии, используемые в процессе вывода, как в случае
        проекта DRuby~\cite{Furr2009}.
        
        Для языка TypeScript~\cite{TypeScript} существует отдельный проект ---
        DefinitelyTyped, в которым собраны такие модули, описывающие интерфейсы
        большого числа популярных библиотек для JavaScript.
      }
      \item{% 
          Получение информации о типах динамически. Сбор данных о типах в
          программе при помощи инструментированного интерпретатора или отладчика
          позволяет получить максимально точные типы для произвольных объектов
          программы, в том числе для тех, которые описаны в скомпилированных
          модулях-расширениях. Недостатки такого способа описаны в разделе
          \hyperref[sec:dynamic-checks]{Динамические методы для сбора информации
          о типах}.
      }

\end{itemize}

\section{Источники информации о типах}
\label{sec:type-sources}

Несмотря на то, что программы на динамически типизированных языках обычно не
содержат явных аннотаций типов переменных и выражений, тем не менее в них
имеется ряд конструкций, которые могут помочь в процессе вывода типов. 

\begin{description}
    \item[Литералы стандартных типов] \hfill \\
        В качестве примеров можно привести
        строковые литералы, целые числа и числа с плавающей точкой, встроенные
        коллекции, логические константы, а также специальные константы символизирующие
        отсутствие значения (!None! в Python, !nil! в Ruby,
        !null! и !undefined! в JavaScript).
        
    \item[Вызовы конструкторов классов] \hfill \\
        Можно сказать, что при выводе типов в объектно-ориентированных языках
        они играют роль литералов не встроенных типов. В Python, однако,
        использование их при выводе осложняется тем, что, во-первых, вызов
        конструкторов синтаксически не отличается от вызовов функций, во-вторых,
        в языке существуют механизмы, из-за которых не гарантируется, что вызов
        конструктора действительно вернет экземпляр соответствующего класса
        (специальный метод !__new__!).

    \item[Опциональные аннотации типов] \hfill \\
        Такие аннотации могут быть либо предусмотрены синтаксисом языка, либо
        являются частью используемого языка программной документации.

    \item[Непосредственные проверки типов] \hfill \\
        Динамически типизированные языки обычно включают средства для явной
        проверки типов значения переменной. В Python они могут
        выглядеть как !isinstance(x, MyClass)! или \\
        !type(x) is MyClass!. В
        сочетании с анализом потока управления в программе, они позволяют
        гарантировать, что на определенных путях, тип значения будет известен. 
        Интересно, что такие проверки не обязательно должны осуществляться в условных
        операторах: например, проверка вида !assert isinstance(x, MyClass)!
        является даже более строгим источником типа переменной !x!, представляя
        собой форму контракта.

    \item[Типы в стандартной библиотеке] \hfill \\
        Типы часто используемых функций стандартной библиотеки могут быть
        известны, например, из документации. Следует отметить, что часто иной
        способ получения информации о них невозможен, потому что стандартная
        библиотека многих динамически типизированных языков написана на C/C++.
        Подробнее эта проблема была рассмотрена в
        разделе~\ref{sec:extensions-and-stdlib}.

    \item[Контекст использования значения] \hfill \\
        Информация о том, как используется значение, также может быть
        использована для вывода его типа. Факт обращения к некоторому атрибуту
        объекта, например, вызов метода, ограничивают множество возможных
        типов, потому что отсутствие нужного атрибута обычно приводит к ошибке
        времени исполнения (!AttributeError! в Python).  Сюда же можно отнести
        использование значения в качестве операнда арифметических и логических
        выражений, так как во многих языках, в частности в Python, использование
        операторов приравнивается к вызову специальных методов, потенциально
        переопределенных в пользовательских классах.

    \item[Эвристические методы] \hfill \\
        Такие методы могут быть в частности основаны на принятых соглашениях по
        поводу именования переменных, например, венгерской нотации
        (\emph{Hungarian notation}) или явном упоминании типов в названиях
        переменных (например, !aString! или !anInteger!),
        использовании коротких имен !i! или !n!  для целочисленных переменных,
        имен во множественном числе для коллекций и др. Подобный анализ был
        применен, например, в проекте MINO~\cite[]{Tu}, использующем техники
        машинного обучения (\emph{machine learning}) для статического вывода
        типов в программах на Python.

    \item[Динамические источники информации о типах] \hfill \\
        Такие данные могут быть собраны, например, в процессе выполнения
        тестов~\cite{Haupt2011} или отладки программы.

    \item[Другие источники] \hfill \\
        Во многих языках программирования имеются специальные синтаксические
        конструкции, помимо литералов, которые также служат точными источниками
        информации о типах. Так, в Python все методы класса, не аннотированные
        как !@staticmethod! или !@classmethod!, явно принимают в качестве первого
        параметра, который принято называть !self!, экземпляр соответствующего
        класса. Следовательно, можно принять, что тип этого параметра всегда
        известен.  Также для специальных параметров функций, имена которых
        начинаются с одного или двух символов !*!, и которые позволяют функциям в
        Python принимать произвольное число позиционных и именованных аргументов,
        известно, что их типами являются стандартные коллекции !tuple! и !dict!
        соответственно.

\end{description}
     
\section{Подходы к выводу типов в динамически типизированных языках}

В этом разделе мы коротко рассмотрим какие решения применяются для вывода
типов выражений в динамически типизированных языках.

\subsection{Локальный вывод только стандартных типов}

Такой подход был использован B. Cannon для вывода стандартных типов (называемых им
атомарными), имеющих в языке специальные литералы. Автор использует алгоритм,
учитывающий поток управления в программе (\emph{flow-sensitive}). Цель работы
--- введение в байт-код интерпретатора CPython новых инструкций, которые
позволили бы избежать дорогостоящих процедур разрешения атрибутов для
стандартных типов, например, коллекций во время исполнения. Однако, к сожалению,
по результатам работы ожидаемого прироста производительности достигнуто не было.

\subsection{Использование аннотаций}

Некоторые из рассмотренных решений предполагают внесение в программу большого
числа дополнительных аннотаций, главным образом для сигнатур функций. Аннотации
обычно добавляются в виде специальных комментариев, однако могут также
использовать возможности синтаксиса целевого языка. В последнем случае проверки
типов осуществляются динамически и потому относятся скорее к динамическим
методами, описанным в следующей категории.

Интересным направлением в этой области, использующимся преимущественно для
Smalltalk, являются подключаемые (\emph{pluggable}) типы~\cite{Haldiman2009},
которые позволяют использовать различные системы типов для статического поиска
конкретных видов ошибок. В качестве примера можно привести вызов метода на
переменной, которая может содержать значение !null! (можно провести аналогию с
аннотациями !@Nullable! и !@NotNull! в Java). 

\subsection{Динамические методы для сбора информации о типах}
\label{sec:dynamic-checks}

В эту категорию попадают, прежде всего явные проверки типов подставляемые в
программу либо инструментированным интерпретатором, либо самим программистом
посредством сторонних библиотек, таких как Ruby Type Checker (RTC)~\cite{Ren2013}
для языка Ruby или открытые проекты
rightarrow\footnote{\url{https://github.com/kennknowles/python-rightarrow}} и
typeannotations\footnote{\url{https://github.com/ceronman/typeannotations}} для
Python.  Они не позволяют найти ошибки статически, и поэтому не так полезны,
например, в составе
сред разработки, однако могут помочь обнаружить ошибки раньше во время
исполнения.  Они также могут проверять более сложные условия, чем принадлежность
значения определенному типу, и по существу являются формой контрактного
программирования.  К недостаткам такого подхода можно отнести негативное влияние
таких проверок на быстродействие программы, а также необходимость вмешательства
программиста, в случае, если он должен вручную вносить такие аннотации. 

Также часто описываются динамические методы, объединяемые термином \emph{type
  feedback} и основанные на собирании информации о типах в процессе исполнения
программы в тех случаях, когда вызванное этим замедление в работе, не
существенно, например, во время выполнения модульных тестов или отладке
программы. В частности описанный в работе~\cite{Haupt2011} метод Type Harvesting
для Smalltalk использует именно модульные тесты для этой цели.

Собранная таким образом информация может использоваться, например, в среде
разработки.  Проблемой такого подхода является то, что он очевидно зависит от
тестового покрытия и того, через какие пути проходит поток исполнения при
отладке программы. Также результатом его использования могут стать излишне
точная информация, например, таким образом нельзя обнаружить функции с
параметрическим полиморфизмом.
