%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор предметной области}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Динамическая типизация и динамические языки}

Динамически типизированными называются языки, в которых проверки типов
происходят во время исполнения программы (\emph{runtime}). Одно из
распространенных определений, принадлежащее G. Steel, часто встречающиеся
в литературе звучит как:

\begin{quote}
  A dynamic language is one that defers as many decisions as possible to
  runtime.
\end{quote}

% Динамически типизированные языки имеют долгую историю в Computer Science. Так
% один из первых языков, использующих динамическую типизацию --- Lisp --- появился
% в 1958 году, т.е. примерно в то же время, что и первый компилятор Fortran.

Здесь и далее мы принимаем за \emph{тип} прагматичное его определение как
верхнюю границу множества возможных значений выражения в
программе~\cite{Cardelli2004}, например, только !True! или !False! для значения
типа !bool! или целое число в диапазоне $[-2^31, 2^31-1]$ для значения типа
!int!.

Статически типизированные языки, с другой стороны, не исключая проверок во время
исполнения, ставят задачу выяснить как можно больше информации о программе
статически, для чего в них применяются формальные методы из теорий статического
анализа и систем типов (\emph{type systems}). 

B. Pierce определяет системы типов как:

\begin{quote}
  A type system is a tractable syntactic method for proving the absence of certain
  program behaviors by classifying phrases according to the kinds of values they
  compute.
\end{quote}

Детали используемой системы типов традиционно являются частью спецификации языка
и оказывают непосредственное влияние на его семантику. Как следствие, ошибки,
допущенные при проектировании системы типов может быть практически невозможно
исправить без разрушения обратной совместимости с существующим приложениями.

% Retrofitting a type system onto a language not designed with typechecking
% in mind can be tricky; ideally, language design should go hand-in-hand with
% type system design.
% One reason for this is that languages without type systems—even safe, dy-
% namically checked languages—tend to offer features or encourage program-
% ming idioms that make typechecking difficult or infeasible. Indeed, in typed
% languages the type system itself is often taken as the foundation of the de-
% sign and the organizing principle in light of which every other aspect of the
% design is considered.

Полученная информация может быть использована как для выполнения компилятором
определенных оптимизаций над программой, так и для предотвращения определенного
класса ошибок (\emph{execution errors}~\cite{Cardelli2004}, \emph{run-time type
  errors}~\cite{Pierce2002}) до ее исполнения. Можно сказать, что системы типов
являются одним из самых широко распространенных средств обеспечения качества ПО.
Для программиста такие результатом таких проверок является то, что определенные
программы могут быть отвергнуты компилятором или линковщиком как содержащие
ошибку типов, и следовательно некорректно типизированные(\emph{ill-typed}).
Такая ошибка может заключаться, например, в присвоении значения несовместимого
типа переменной в программе или в обращении к несуществующему методу в программе
на Java, так и свидетельствовать о более сложных нарушениях в программе в
зависимости от выразительности языка и его системы типов.

Для того чтобы гарантировать работоспособность такого анализа, системы типов
являются традиционно являются консервативными: факт того, что программа
прошла проверку означает, что она \emph{не содержит} ошибку, однако обратное не
гарантируется, то есть именно корректная программа может быть признана ошибочной.
Самым простым примером является ошибка типа в недостижимом участке программы,
например, в ветви условного оператора, которая никогда не выполняется. 

Также для обеспечения работы механизма проверки типов на практике большинство применяемых
сегодня систем типов требуют вмешательства программиста через внесение им в программу
явных аннотаций типов (\emph{type annotations}). L. Cardelli называет такие
языки явно типизированными (\emph{explicitly typed}). Количество таких
аннотаций, тем не менее, может сильно варьироваться в конкретных языках: от
практически тотального аннотирования программ на Java до отдельных аннотаций, в
местах где возникает неоднозначность (\emph{ambiguity}), в Haskell и других
функциональных языках семейства ML. Последние используют алгоритмы вывода типов
(\emph{type inference}), позволяющие опустить значительную часть аннотаций
путем вывода типов из контекста, в котором используется выражение.  Такие языки
называются неявно типизированными (\emph{implicitly typed}). 

Также отмечается~\cite{Pierce2002}, что система типов работает наиболее
эффективно, когда программист в полной мере использует ее возможности, в
частности по определению новых пользовательских типов, более точно описывающих
предметную область приложения и, как следствие, задающих большее число ограничений
которые могут быть проверены статически.

% Например, для программы на Java, все сложные
% структуры данных которой выражаются через стандартные коллекции, такие как
% !ArrayList! или !HashMap!, компилятор не сможет найти значительную часть ошибок
% вроде сохранения значения неправильного типа. 

Вышеописанные ограничения, иногда воспринимающиеся как искусственно ``навязанные''
программисту системой типов, зачастую перегруженный аннотациями синтаксис языка,
а также то, что большинство логических ошибок в программе, таких как, например,
выход за пределы массива или деление на ноль, обнаружить статически все равно не
удается --- все это, во-первых, побуждает исследователей разрабатывать более
сложные и выразительные систем типов, во-вторых, способствует широкому
применению языков с динамической типизацией, которые лишены этих проблем.

В отсутствии статических проверок, предоставляемых системой типов, для
обеспечения качества ПО при разработке на динамически типизированных языках
применяются другие методы, главным из которых является обширное модульное
тестирование программ. Также получили распространение динамические проверки, в том
числе основанные на использовании контрактного программирования, а также
различные пакетные (\emph{batch}) статические анализаторы. Последние обычно
включают в себя процесс разрешения типов выражений, однако из-за ряда
особенностей, присущих динамически типизированным языкам и описываемых далее в
этой главе, известные алгоритмы, применяющиеся в статически типизированных
языках, оказываются либо крайне неэффективными либо, либо вовсе неприменимыми.

Среды разработки (IDE) позволяют наиболее тесно интегрировать статический анализ
для поиска ошибок в процесс написания программ, однако, будучи
интерактивными инструментами непосредственно взаимодействующими с пользователем
сильно зависят от времени анализа, а также от точности его результатов и поэтому
часто не могут использовать даже тех алгоритмов, которые используются в пакетных
анализаторах. Между тем, точный вывод типов положительно бы сказался и на
другой функциональности IDE, например, автодополнении, навигации по проекту или
проведении автоматических рефакторингов.

\nomenclature{IDE}{Integrated Development Environment}

\section{Сложности вывода типов в динамически типизированных языках}
\label{sec:difficulties}

Прежде чем перейти к рассмотрению существующих решений, перечислим некоторые
особенности динамически типизированных языков определяющие специфику и сложность
вывода типов в них.

\subsection{Типы переменных}

В программах на динамически типизированных языках одна и та же переменная может
хранить значения произвольных типов, а функция возвращать несколько
несовместимых по типу значений. Сюда же можно отнести гетерогенные коллекции,
например, списки содержащие элементы различных типов. Сложность заключается в
том, что в программе может происходить обращение к их элементу по индексу как к
значению конкретного типа. И, если для неизменяемых коллекций, таких как кортежи
в Python, можно в какой-то степени гарантировать, что это обращение будет
успешным, то для изменяемых коллекций или коллекций, не гарантирующих порядок
элементов, сделать это значительно сложнее. Небольшой обзор проблем связанных с
анализом гетерогенных коллекций можно найти в работе~\cite[]{Salib2004}. 
Для того чтобы статически протипизировать такую программу в условиях подобной
вариативности типов в систему типов вводятся такими абстракции, как
типы-пересечения и типы-объединения. Исследования возможности использования
подобных типов в статически типизированных
языках~\cite[]{Igarashi2006,Ortin2011:union}  показывают, что уже это является
нетривиальной проблемой.

\subsection{Метапрограммирование и динамические возможности}

Одной из характерных особенностей языков с динамической типизацией являются
значительно расширенные по сравнению со статически типизированными языками
возможности метапрограммирования. Причем речь идет не только о возможностях
интроспекции, то есть анализа программой самой себя, но о структурном изменении
существующих объектов, а также добавлении новых непосредственно в процессе
исполнения. Например, добавление новых методов и полей как самим классам, так и
конкретным их экземплярам, или интерпретация содержимого строки как фрагмента
программы --- возможности недоступные или чрезвычайно трудоемкие для языков со
статической типизацией.

В работе~\cite[]{Holkner2009} приводится следующая классификация динамических возможностей
программ на Python, включающих в себя средства метапрограммирования: 

\begin{itemize}
  \item{Рефлексия (\emph{reflection}). 
      Использование объекта через мета-объектные механизмы, например,
      чтение или запись атрибут по его имени, вызов метода по его имени или
      исследование объекта и его класса. Не является уникальной для языков с
      динамической типизацией, похожие механизмы имеются в языках с виртуальной
      машиной (\emph{managed languages}), например, Java и C\#.}
  \item{Динамическая типизация (dynamic typing). 
      Упомянутое уже отсутствие
      ограничений на возможный тип значений переменной.  Динамические объекты
      (dynamic objects). Возможность изменять структуру классов и объектов в
      программе: добавлять к ним новые методы и поля, а также удалять и добавлять
      существующие. Здесь следует отметить, что возможности по изменению встроенных
      типов, например, базового класса object или стандартных коллекций, в Python, в
      отличие от, например, Ruby~\cite{Madsen2007}, невозможны без применения сторонних библиотек.
      Часто упоминающаяся возможность изменять список базовых классов у уже
      определенного класса, также не всегда допустима.}
  \item{  
      Динамический код (\emph{dynamic code}).
      В эту категорию авторы относят все стандартные средства для
      генерации и исполнения программы из исходных текстов во время ее
      исполнения.  Например, функции !exec! и !eval! в Python.  Интересно, что в ряде
      работ по выводу типов в динамически типизированных языках,
      например~\cite{Salib2004,Aycock2000},  их авторы опираются на предположение о
      том, что подобные возможности языка используются достаточно редко, и поэтому
      ими можно пренебречь в процессе вывода типов, что естественно негативно
      сказывается на точности анализа. Например, в~\cite{Aycock2000} J. Aycock пишет:
      \begin{quote}
        Giving people a dynamically-typed language does not mean that they write
        dynamically typed programs.
      \end{quote}
      Для проекта PyPy был даже создан диалект Python --- RPython (Restricted
      Python)~\cite{Ancona2007}, который сохраняя привычный синтаксис языка по своим
      возможностям в большей степени близок к Java: типы переменных фиксированы,
      наследование от единственного суперкласса, а все перечисленные средства
      метапрограммирования недоступны.  Между тем, в работе~\cite{Holkner2009} было проведено
      исследование ряда существующих программ, где при помощи инструментированного
      интерпретатора оценивалось, насколько велико использование подобных
      динамических возможностей в действительности и от каких из них можно было бы
      отказаться в конкретных случаях. Их результаты показывают, что все,
      рассмотренные ими программы используют динамические возможности языка, и в них
      нельзя выделить однозначно выделить этап после которого эти возможности не
      используются --- что применяется в проекте PyPy.
    }
\end{itemize}

\subsection{``Утиная'' типизация (duck typing)}

Утиная типизация (\emph{duck typing}) является настолько характерной для динамически
типизированных языков, что иногда можно встретить использование
выражения ``duck-typed language'' в качестве синонима динамически типизированного
языка. Суть похода заключается в том, что для того, чтобы два типа были
совместимы не требуется какoе-либо формальное задание отношений между ними,
например, наличие общего предка в иерархии классов, как в Java, а лишь совместимость их
интерфейсов (здесь идет речь об интерфейсах в общем смысле --- как о множестве
доступных для обращения атрибутов объекта). При этом это полного совпадения не
требуется --- только тех атрибутов, которые реально используются. 
Например, если мы хотим, чтобы некоторая функция принимала в
качестве аргумента значение некоторого типа, имеющего метод !draw!, не нужно
выделять суперкласс содержащий этот метод, достаточно лишь, чтобы такой метод
просто был доступен для обращения и вызова. Если больше ни к каким атрибутам
объекта обращение не происходит, их имена и типы не имеют значения.

\pagebreak
\begin{lstlisting}
class Cowboy:
    def draw(self):
        print('Drawing a gun')

class Pen:
    def draw(self):
        print('Drawing a line')

def draw_something(o):
    o.move()
\end{lstlisting}

Нередко в литературе можно встретить описание типов объектов в терминах
сообщений (\emph{messages}), которые они могут принять. Например, в Smalltalk
сообщения называются селекторами (\emph{selectors}), а объект, на них отвечающий, ---
приемником (\emph{receiver}). Сообщениями считаются вызовы методов и обращения к полям
объекта. В языках с ``утиной'' типизацией, конкретные классы не играют роли, так
как их имена фигурируют лишь при их объявлении, важно лишь, чтобы объект мог
ответить на необходимое сообщение.  

Интересно, что из-за ``утиной'' типизации наследование, которое в статически
типизированных объектно-ориентированных языка, таких как Java, является
одним из основных механизмом внесения полиморфизма в программу (так называемый
полиморфизм подтипов, англ. \emph{subtyping polymorphism}),
в языках с динамической типизацией становится преимущественно средством
повторного использования кода. В частности уменьшается роль интерфейсов и
абстрактных классов, несмотря на то, что, например, в Python такие возможности
имеются. В качестве примера можно привести использование в
стандартной библиотеке Python так называемых протоколов. Например, класс, в
котором определен метод !__iter__! удовлетворяет протоколу
итерируемого объекта (\emph{Iterable}), что делает возможным его использование,
например в циклах !for! и !while!, а класс, содержащий методы
!__iter__! и !__next__! --- протоколу итератора
(\emph{Iterator}).  Введения специальных интерфейсов !Iterable!
и !Iterator!, как в Java, не требуется.

Утиная типизация очень близка к понятию структурной эквивалентности
(\emph{structural equivalence}) типов, которой противопоставляется номинальная
эквивалентность (\emph{nominal equivalence}) типов (также используются понятия
номинальной и структурной систем типов).

Benjamin Pierce пишет про номинальные и структурные системы типов в~\cite{Pierce2002}.

\begin{quote}
Type systems like Java’s, in which names are significant and subtyping is
explicitly declared, are called nominal. Type systems like most of the ones in
this book, in which names are inessential and subtyping is defined directly on
the structures of types are called structural.
(B.~Pierce)
\end{quote}

К преимуществами номинальных систем типов, помимо некоторых упрощений в
имплементации алгоритмов проверки типов и среды исполнения языка относят то,
что она не позволяет считать эквивалентными два типа идентичные структурно, но
описывающие различные принципиально несовместимые сущности в программе.
Например, если имеются два структурно эквивалентных типа !Point! и
!TextRange!, но у !TextRange! также имеется ограничение на
возможные значения полей !x! и !y!, передача объекта !Point! вместо
TextRange может привести к нарушению инвариантов в программе.

\begin{lstlisting}
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class TextRange:
    def __init__(self, x, y):
        if y < x or x < 0:
            raise ValueError('Illegal range: must be y >= x && x >= 0')
        self.x = x
        self.y = y
\end{lstlisting}

В то же время, к недостаткам номинальных систем типов относят сложность их
расширения: если на каком-то этапе потребуется обеспечить совместимость двух
классов не имеющих общего предка, единственный способ сделать это --- определить
и внести новый абстрактный класс или интерфейс, который они будут наследовать,
что не всегда возможно.  

\begin{quote}
However, interfaces cannot be added once a class is defined, so library
designers still have to do a lot of planning of their interface hierarchies
before the library is shipped. This problem has been considered a significant
limitation of type systems with declaration-based subtyping, as in Java.
(B.~Pierce)
\end{quote}

Интересным расширением номинальной системы типов, позволяющим обойти это
ограничение, являются типы-объединения (\emph{union-types}), содержащие методы
общие для всех входящих в объединение классов. Например, в
работе~\cite{Igarashi2006} рассматривается использование типов-объединений, а
также изменения, которые потребуется внести в систему типов и правила вывода, в
исследовательском диалекте языка Java --- Featherweight Java.

Структурные системы типов нашли свое место и в языках со статической
типизацией, например Go и OCaml~\cite[с.~33]{Ocaml}, а также в проекте
TypeScript~\cite[]{TypeScript} --- диалекте JavaScript с опциональной
типизацией. 

Приведенный ранее пример с методом draw выглядел бы в OCaml как

% language=[Dialect]Language cannot be used with lstlisting environment
% directly
\lstset{language=[Objective]Caml}
\begin{lstlisting}
class cowboy =
    object (self)
        method draw =
            print_string "Drawing a gun"
    end

class pen = 
    object (self) 
        method draw =
         print_string "Drawing a line"
    end

let draw_something o =
    o#draw

\end{lstlisting}

Функция в данном случае !draw_something! имеет следующий тип

\begin{lstlisting}
val draw_something : < draw : 'a; .. > -> 'a = <fun>
\end{lstlisting}

Более того, можно даже создать объект без ассоциированного с ним класса --- так
называемый \emph{immediate object} --- содержащий метод !draw!, его так
же можно будет передать в функцию !draw_something!.

\begin{lstlisting}
# let o = object
      method draw = print_string "draw called on immediate object"
  end;;

val o : < draw : unit > = <obj>
# draw_something o;;
draw called on immediate object- : unit = ()
\end{lstlisting}
\lstset{language=Python}

В работе~\cite{Ortin2011:union} описывается использование подобной техники
применительно к динамически типизированным вставкам в разработанном авторами
языке StaDyn, транслирующимся в программы на языке C\# с использованием
появившегося в C\# 4.0 ключевого слова !dynamic!.  Авторы называют такие
типы --- типами-пересечениями (\emph{intersection types}), представляя каждое
обращение к методу или полю объекта, как неявное определение нового типа. Тип,
объединяющий все такие элементарные типы, считается их пересечением.

В работе~\cite{Pluquet2009}, посвященной разработке быстрого алгоритма вывода
типов для Smalltalk, авторы называют такие структурные типы интерфейсными 
\emph{interface types}. После сбора информации о передаваемых объекту сообщениях,
происходит анализиз иерархии известных системе классов в поисках наиболее
точного типа, имеющего необходимую сигнатуру. Такой алгоритм фактически
совмещает структурную и номинальную системы типов, сначала инерпретируя типы
объектов структурно для сбора наиболее точной информации, а затем пытаясь
представить их в более привычном для программиста виде --- через имена
конкретных классов в проекте.

\section{Типы функций}

Вывод точных типов функций в программах на динамически типизированных языках
представляет особенно сложную проблему. Если для локальных переменных обычно
оказывается возможным вывести информацию об их типах из контекста в котором они
были определены, например, через использование литерала одного из встроенных
типов или вызов конструктора (более подробно источники информации о типах
описаны в разделе \hyperref[sec:type-sources]{2.1 Источники информации о типах}), то
для параметров функций в отсутствии каких-либо аннотаций, единственными
источниками информации о их предполагаемых типах становятся, во-первых,
использование значений параметров в теле функции, например, ранее описанная
передача им сообщений, во-вторых, типы аргументов передаваемых в функцию при ее
вызовах (\emph{call sites}).

Особую сложность представляют функции с параметрическим полиморфизмом, в
которых тип возвращаемого значения зависит от конкретных типов аргументов, 
потому что для таких функций информация о типах аргументов не является
источником точной информации о возможных значениях параметров.
Простейшим примером такой функции является функция идентичности,
которая возвращает единственный аргумент.

\begin{lstlisting}
def id(x):
    return x
\end{lstlisting}

Одним из хорошо известных алгоритмов для решения этой проблемы является 
Cartesian Product Algorithm, разработанных в 1995 году Ole Ageseen для языка
SELF.

\nomenclature{CPA}{Cartesian Product Algorithm}

% From a type inference perspective, Python is a large and complex language. In contrast to other languages that rely heavily on type inference for performance, such as Eiffel, Haskell, or the many variants of ML, Python was designed with little thought as to how the language semantics would hinder or help type inference. Instead, Python’s semantics evolved over several years in response to feedback from a community of skilled practitioners. Thus, while languages like Haskell suffer occasional design flaws that had to be imposed specifically to make type inference easier, Python makes no such compromises in its design, which only makes Starkiller’s job that much harder.

\section{Источники информации о типах}
\label{sec:type-sources}


Несмотря на то, что программы на динамически типизированных языках обычно не
содержат явных аннотаций типов переменных и выражений, тем не менее в них
имеется ряд конструкций, которые могут помочь в процессе вывода типов. 

\begin{itemize}
    \item{Литералы стандартных типов. В качестве примеров можно привести
        строковые литералы, целые числа и числа с плавающей точкой, встроенные
        коллекции, логические константы, а также специальные константы символизирующие
        отсутствие значения (!None! в Python, !nil! в Ruby,
        !null! и !undefined! в JavaScript).}
    \item{Вызовы конструкторов классов.}
    \item{Опциональные аннотации типов, либо предусмотренные синтаксисом языка, либо
        являющиеся языка документации.}
    \item{Непосредственные проверки типов переменных перед использованием их
        значения.}
    \item{Информация о сигнатурах функций, используемых в стандартной
        библиотеке. Эту информацию часто оказывается невозможно не собрать иными
        средствами, так как компоненты стандартной библиотеки многих
        динамических языков написаны на C/C++. В частности для этого
        используются анализ документации и анализ этих модулей с использованием
        рефлексивных возможностей языка.}
    \item{Контекст в котором используется переменная или результат выражения, 
        например, вызываемые методы или используемые операторы.}
    \item{Эвристические методы, основанные, на принятых форматах
        именования переменных, например, венгерской нотации (\emph{Hungarian
          notation}) или явном упоминании типов в названиях переменных (например,
        !aString!), использовании коротких имен !i! или !n!
        для целочисленных переменных, имен во множественном числе для коллекций
        и др. Подобный анализ, применен, например, в работе~\cite[]{Tu}.
    }
\end{itemize}
     

