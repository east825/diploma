%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Проектирование}
\label{sec:designing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Описание алгоритма}

Как уже было отмечено, вывод типов параметров функций в настоящий момент
является в PyCharm проблемой решенной лишь частично. Возьмем функцию
!slugify(s)!, определенную таким образом:

\begin{lstlisting}[
  caption={Функция \texttt{slugify(s)}.},
  label=slugify
]
def slugify(s):
    return '-'.join(s.split())
\end{lstlisting}

Посмотрев на тело функции можно догадаться о ее назначении: разбиение строки на
слова с последующей конкатенацией их через дефис. Программист предполагает
сигнатуру функции $(str) \rightarrow str$. Естественно, что в условиях ``утиной
типизации'' в действительности в качестве аргумента !s! может быть использован любой
объект, имеющий метод !split()!, поэтому при отсутствии каких-либо явных
аннотаций, например, в формате системы документации Sphinx
(листинг~\ref{slugify-sphinx}), PyCharm пессимистично считает тип аргумента !s!
неопределенным, однако выводит тип возвращаемого значения функции как !str!,
потому что тип возвращаемого значения стандартного метода !str.join(seq)!
известен. Таким образом, итоговый тип функции !slugify(s)! --- $(unknown)
\rightarrow str$.

\begin{lstlisting}[
  caption={Функция \texttt{slugify(s)} c аннотациями в формате Sphinx.},
  label=slugify-sphinx
]
def slugify(s):
    """
    :type s: str
    :rtype: str
    """
    return '-'.join(s.split())
\end{lstlisting}

Неизвестный тип параметра мог бы быть выведен из мест вызова функции, например, 
!slugify('foo bar baz')!, но, во-первых, с целью повышения быстродействия в
PyCharm используются только вызовы функции в том же модуле, где она объявлена,
а, во-вторых, это не поможет на этапе, когда функция только пишется, хотя
в этот момент знание типа параметра !s! средой разработки оказалось бы наиболее
полезным, например, для автодополнения других методов класса !str!, таких как,
!lower()!.

Главной идеей алгоритма, предлагаемого в данной работе, является использование
информации об обращениях к методам и полям параметра функции для поиска
подходящих по интерфейсу классов среди известных системе. Здесь мы
придерживаемся терминологии, принятой в Python, и называем чтение и запись полей
класса, а также вызовы методов объекта совместно обращениями к атрибутам
(\emph{attributes access}). В других динамически типизированных
объектно-ориентированных языках аналогичная по семантике конструкция может
называться иначе, например, \emph{передача сообщения} (\emph{message passing},
или \emph{message sending}) в Smalltalk и SELF.

С каждым параметром функции в программе связывается \emph{структурный тип},
включающий все атрибуты параметра, к которым происходит обращение внутри
функции. Так, для параметра !s! функции !slugify! структурный тип ---
$\{split\}$, что записывается как 

\[
    slugify.s :: \{ split \}
\]

В стандартной библиотеке Python находится несколько типов, интерфейс которых
включает метод !split()!: !bytearray!, !bytes! и !str!. Если, например, где-либо
в проекте определен также пользовательский класс с этим методом, он также
включается в это множество. При этом из ряда возможных классов, всегда должен
быть найден наиболее общий, то есть находящийся наиболее высоко в иерархии
классов и удовлетворяющий заданному структурному типу (общий предок приведенных
стандартных классов --- !object! не содержит метода !split()!).

В целом алгоритм вывода типов для параметра функции работает в три этапа:

\begin{enumerate}
    \item{Первоначальная индексация проекта с целью поиска определений классов.
      Выполняется полностью только один раз.}
    \item{Поиск атрибутов параметра, к которым выполняется обращение в теле
        функции.}
    \item{Подбор номинальных типов, т.е. в случае Python --- классов, подходящих
      по интерфейсу.}
\end{enumerate}

Такой подход не является уникальным, так как идеи использования структурных
типов для описания типов объектов уже высказывались в других работах.
Однако, например, в работе~\cite{Pluquet2009}, где описывается алгоритм поиска
классов в программах на Smalltalk, алгоритм подбора классов требует
первоначального построения единой иерархии всех известных классов, что вступает
в конфликт с описанным ранее требованием инкрементальности, так как неясно, как
подобную иерархию можно инкрементально обновлять, тем более в условиях
множественного наследования в Python.  Авторы проекта Diamondback
Ruby~\cite{Furr2009}, с другой стороны, введя объектные типы (\emph{object
  types}) в свою систему типов, отказались от идеи подбора подходящих классов,
аргументируя это тем, что это разрушило бы модульность их анализа.

\begin{quote}
  If we wanted to stick to nominal typing only, we could try to find all classes
  that have methods foo and bar, and then give [an argument] a type that is the
  union of all such classes. However, this would be both extremely messy and
  non-modular, since changing the set of classes might require updating the type
  of [function].
\end{quote}

Проблему неинкрементальности, или немодульности, поиска классов по атрибутам, к
которым происходит обращение нетрудно проиллюстрировать. Допустим, что в
программе на Python имеется четыре следующих определения:

\begin{lstlisting}[
  caption={Пример разрешения классов при наследовании.}
]
class A:
    def foo(self):
        pass

class B(A):
    def bar(self):
        pass

class C:
    def foo(self):
        pass


def func(x):
    x.foo()
    x.bar()

\end{lstlisting}

Для людей, незнакомых с синтаксисом Python, поясним, что в круглых скобках после
имени класса при его определении указываются имена его базовых классов
через запятую. Например, в данном случае класс !B! наследуется от !A!.

Так как !B! --- единственный класс в программе, в котором имеются и метод
!foo()!, и метод !bar()!, то логично предположить, что он должен стать
результатом вывода типа параметра !x!  функции !func!. Однако метод !foo()!
непосредственно к классе !B!  не объявлен и доступен ему посредством
наследования от класса !A!. Поиск определения класса !A! для нахождения
определенных в нем атрибутов включает процедуру разрешения имени (\emph{name
  resolution}), которая в свою очередь требует использования индексов.
Представим теперь, что все четыре определения находятся в разных модулях
программы, которые \emph{индексируются независимо}. Мы не можем совместить
индексирование и разрешение имен, сразу сохранив в индексе для конкретного
класса все доступные ему атрибуты (с учетом наследования).  Даже если бы это
было возможно, например, через несколько проходов индексации, изменение
суперкласса --- класса !A! в данном случае --- потребовало бы изменения
содержимого индексов для всех его наследников, т.е. для класса !B!. 

Есть несколько тривиальных путей решения данной проблемы. Одним из них является
использование при выводе только атрибутов, непосредственно определенных в классе
(без учета наследования). В этом случае можно было бы либо подбирать только
классы, в которых непосредственно определен по крайней мере один из используемых
атрибутов параметра, либо подбирать только те, где определены все сразу. Однако
первый вариант неизбежно привел бы к большому числу в действительности
неподходящих классов, например, класса !C! в приведенном примере, тогда как второй
исключил наследование атрибутов вовсе, и для параметра !x! не было бы
найдено ни одного подходящего класса.

Альтернативным решением является разрешение атрибутов по иерархии наследования
\emph{при каждом поиске классов для параметра функции}. В этом случае требование
инкрементальности будет сохранено, потому как индекс классов будет включать
только атрибуты, определенные в них непосредственно. Псевдокод процедуры для
подбора классов по структурному типу приведен в листинге~\ref{algorithm}. 

\begin{algorithm}
  \caption{Алгоритм подбора классов по структурному типу.}
  \label{algorithm}
  \begin{algorithmic}
  \small
  \Function{SuggestClasses}{$accessedAttributes$}
    \State $candidates \gets \bigcup_{\forall a \in accessedAttributes} Index(a)$
    \State $suitable \gets \emptyset$
    \State $seen \gets \emptyset$
    \While{$candidates \ne \emptyset$}
      \State $class \gets Pop(candidates)$
      \State $seen \gets seen \cup \{class\}$
      \State $bases \gets resolveBases(class)$
      \State $availableAttributes \gets Attributes(class) \cup \bigcup_{\forall{b} \in bases} Attributes(b)$
      \If{$accessedAttributes \subseteq availableAttributes$}
        \State $suitable \gets suitable \cup \{candidate\}$
      \EndIf
      \ForAll{$base \in bases$}
        \If{$base \in seen$}
        \State \textbf{continue}
        \EndIf
          \If{$\exists a \in Attributes(base): a \in accessedAttributes$}
            \State $candidate \gets candidate \cup \{base\}$
          \EndIf
      \EndFor
    \EndWhile
    \ForAll{$class \in suitable$}
      \If{$\exists b \in resolveBases(class): b \in suitable$}
        \State $suitable = suitable \setminus \{ class \}$
      \EndIf
    \EndFor
  \State \textbf{return} $suitable$
  \EndFunction
  \end{algorithmic}
\end{algorithm}


Разработанный алгоритм имеет в худшем случае сложность $O(n^2*k)$, где $n$ ---
количество проиндексированных классов и $k$ --- количество атрибутов параметра,
к которым происходит обращение, что может подставить под сомнение применимость
такого решения в интерактивном инструменте, таком как среда разработки. 

Для проверки применимости, а также оценки свойств данного алгоритма был написан
прототип на Python, позволивший собрать определенную статистику путем анализа
нескольких десятков проектов с открытыми исходными текстами.

Прототип лишен возможностей по статическому анализу, имеющихся в PyCharm и
использует модуль стандартной библиотеки Python !ast! для построения абстрактных
синтаксических деревьев (\emph{abstract syntax tree} --- AST). Так как он был
написан преимущественно для сбора статистики в нем принимается ряд допущений:

\nomenclature{AST}{Abstract Syntax Tree}

\begin{itemize}
    \item Анализируемые программы не должны содержать синтаксических ошибок,
        поскольку в отличии от парсера PyCharm, модуль !ast! не способен
        разбирать такие программы.

    \item Прототип не учитывает потока исполнения и алиасинга внутри функций, что
        может потенциально приводит к менее точным результатам.

    \item Также прототип имеет ограниченные возможности по разрешению имен в проектах, в
        частности не учитывает условных и локальных импортов. В целом считается,
        что каждое имя внутри модуля объявлено только один раз.

    \item Прототип не повторяет имеющуюся функциональность PyCharm по
        выводу типов параметров функций. В частности он не учитывает типы
        значений аргументов по-умолчанию, а также типы аргументов в местах
        вызова функции. 

\end{itemize}

Также в прототипе первые два этапа работы алгоритма: индексация классов и поиск
атрибутов параметров функций объединены в одном проходе, а индексы в отличии от
PyCharm, не сохраняются на диск и перестраиваются при каждом запуске прототипа.

% \section{Описание алгоритмов}

% \subsection{Cartesian product algorithm}
% \label{sub:CPA}

% Ole Ageseen, один из разработчиков языка SELF в 1995 предложил алгоритм
% Cartesian Product Algorithm (CPA)~\cite{Agesen1995}, позволяющий выводить
% конкретные типы аргументов для полиморфных функций. Достигается это следующим
% образом.

% Сначала собирается вся первоначально доступная информация о типах выражений и
% переменных в программе и распространяется посредством анализа графа потока
% данных (Data Flow Graph --- DFG).  Затем для каждого случая вызова функции
% информация о возможных типах аргументов используется для вывода типа ее
% возвращаемого значения. Причем поскольку из-за динамической типизации аргумент
% может принимать значение одного из нескольких возможных типов, собирается
% декартово произведение множеств возможных типов аргументов и анализ происходит
% для каждого кортежа в отдельности (отсюда название алгоритма). Каждая из
% обнаруженных комбинаций типов аргументов анализируется один раз.

% Как отмечается в работе~\cite{Madsen2007} работы O. Agessen не раскрывают
% многих аспектов практического применения алгоритма, к тому же целевой язык SELF
% имеет ряд отличий от современных высокоуровневых динамически типизированных
% языков таких как Ruby или Python. Тем не менее с момента его создания CPA
% применялся в ряде различных проектов~\cite{Madsen2007,Salib2004,Hanov},
% посвященных выводу типов в языках с динамической типизацией, и зарекомендовал
% себя как достаточно точное и эффективное решение.
