%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Проектирование}
\label{sec:designing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Описание алгоритма}

Как уже было отмечено, вывод типов параметров функций в настоящий момент
является в PyCharm проблемой решенной лишь частично. Возьмем функцию
!slugify(s)!, определенную таким образом:

\begin{lstlisting}[
  caption={Функция \texttt{slugify(s)}.} 
]
def slugify(s):
    return '-'.join(s.split())
\end{lstlisting}

Посмотрев на тело функции можно догадаться о ее назначении: разбиение строки на
слова с последующей конкатенацией их через дефис. Программист предполагает
сигнатуру функции \texttt{(str) -> str}. Естественно, что в условиях ``утиной
типизации'' в действительности в качестве аргумента !s! может быть использован любой
объект, имеющий метод !split()!, поэтому при отсутствии каких-либо явных
аннотаций, например, в формате системы документации Sphinx, PyCharm
пессимистично считает тип аргумента !s! неопределенным, однако выводит тип
возвращаемого значения функции как !str!, потому что тип возвращаемого значения
стандартного метода !str.join(seq)! известен. Таким образом, итоговый тип функции
!slugify(s)! --- \texttt{(s: unknown) -> str}.

\begin{lstlisting}[
  caption={Функция \texttt{slugify(s)} c аннотациями в формате Sphinx.}
]
def slugify(s):
    """
    :type s: str
    :rtype: str
    """
    return '-'.join(s.split())
\end{lstlisting}

Неизвестный тип параметра мог бы быть выведен из мест вызова функции, например, 
!slugify('foo bar baz')!, но, во-первых, с целью повышения быстродействия в
PyCharm используются только вызовы функции в том же модуле, где она объявлена,
а, во-вторых, это не поможет на этапе, когда функция только пишется, хотя
в этот момент знание типа параметра !s! средой разработки оказалось бы наиболее
полезным, например, для автодополнения других методов класса !str!, таких как,
!lower()!.

Главной идеей алгоритма, предлагаемого в данной работе, является использование
информации об обращениях к методам и полям параметра функции в ее теле с
последующим поиском подходящих по интерфейсу классов среди известных. Здесь мы
придерживаемся терминологии, принятой в Python, и называем чтение и запись полей
класса, а также вызовы методов объекта совместно обращениями к атрибутам
(\emph{attributes access}). В других динамически типизированных
объектно-ориентированных языках аналогичная по семантике конструкция может
называться иначе, например, \emph{передача сообщения} (\emph{message passing},
или \emph{message sending}) в Smalltalk и SELF.

В целом алгоритм предлагаемый вывода типов для параметра функции работает в три этапа:

\begin{enumerate}
    \item{Первоначальная индексация проекта с целью поиска определений классов.
      Выполняется полностью только один раз.}
    \item{Поиск атрибутов параметра, к которым выполняется обращение в теле
        функции.}
    \item{Подбор номинальных типов, т.е. в случае Python --- классов, подходящих
      по интерфейсу.}
\end{enumerate}

Такой подход не является новым, так как идеи использования структурных типов для
описания типов объектов уже высказывались в нескольких работах.  Однако,
например, в работе~\cite{Pluquet2009}, где описывается алгоритм поиска классов в
программах на Smalltalk, алгоритм подбора классов требует первоначального
построения единой иерархии всех известных классов, что вступает в конфликт с
описанным ранее требованием инкрементальности, так как неясно, как подобную
иерархию можно инкрементально обновлять, тем более в условиях множественного
наследования в Python.  Авторы проекта Diamondback Ruby~\cite{Furr2009}, с
другой стороны, введя объектные типы (\emph{object types}) в свою систему типов,
отказались от идеи подбора подходящих классов, аргументируя это тем, что это
разрушило бы модульность их анализа.

\begin{quote}
  If we wanted to stick to nominal typing only, we could try to find all classes
  that have methods foo and bar, and then give [an argument] a type that is the
  union of all such classes. However, this would be both extremely messy and
  non-modular, since changing the set of classes might require updating the type
  of [function].
\end{quote}

Проблему неинкрементальности, или немодульности, поиска классов по атрибутам, к
которым происходит обращение нетрудно проиллюстрировать. Допустим, что в
программе на Python имеется четыре следующих определения:

\begin{lstlisting}[
  caption={Пример разрешения классов при наследовании.}
]
class A:
    def foo(self):
        pass

class B(A):
    def bar(self):
        pass

class C:
    def foo(self):
        pass


def func(x):
    x.foo()
    x.bar()

\end{lstlisting}

Для людей, незнакомых с синтаксисом Python, поясним, что в круглых скобках после
имени класса при его определении указываются имена его базовых классов
через запятую. Например, в данном случае класс !B! наследуется от !A!.

Так как !B! --- единственный класс в программе, в котором имеются и метод
!foo()!, и метод !bar()!, то логично предположить, что он должен стать
результатом вывода типа параметра !x!  функции !func!. Однако метод !foo()!
непосредственно к классе !B!  не объявлен и доступен ему посредством
наследования от класса !A!. Поиск определения класса !A! для нахождения
определенных в нем атрибутов включает процедуру разрешения имени (\emph{name
  resolution}), которая сама требует использования индексов.  Представим теперь,
что все четыре определения находятся в разных модулях программы, которые
\emph{индексируются независимо}. Мы не можем совместить индексирование и
разрешение имен, сразу сохранив в индексе для конкретного класса все доступные
ему атрибуты (с учетом наследования).  Даже если бы это было возможно, например,
через несколько проходов индексации, изменение суперкласса --- класса !A! в
данном случае --- потребовало бы изменения содержимого индексов для всех его
наследников, т.е. для класса !B!. 

Есть несколько тривиальных путей решения данной проблемы. Одним из них является
использование при выводе только атрибутов, непосредственно определенных в классе
(без учета наследования). В этом случае можно было бы либо подбирать только
классы, в которых непосредственно определен по крайней мере один из используемых
атрибутов параметра, либо подбирать только те, где определены все сразу. Однако
первый вариант неизбежно привел бы к большому числу в действительности
неподходящих классов, например, класса !C! в приведенном примере, тогда как второй
исключил наследование атрибутов вовсе, и для параметра !x! не было бы
найдено ни одного подходящего класса.

Альтернативным решением является разрешение атрибутов \emph{при каждом поиске
 классов для параметра функции}. В этом случае требование инкрементальности
будет сохранено, потому как индекс классов будет включать только атрибуты,
определенные в них непосредственно. Однако возникает вопрос о быстродействии
такого решения, особенно в контексте использования его в среде разработке. 

Разработанный алгоритм имеет в худшем случае сложность $O(n^2)$, где $n$ ---
количество проиндексированных классов. Однако на практике по результатам испытаний даже в
очень больших проектах, включающих тысячи определений классов и функций вывод
типов для \emph{всех параметров всех функций} занимает доли секунды, что
достигается за счет кэширования найденных базовых классов.

\todo{Добавить псевдокод алгоритма}

Для проверки применимости, а также оценки свойств данного алгоритма был написан
прототип на Python, позволивший собрать определенную статистику путем анализа
нескольких десятков проектов с открытыми исходными текстами.

Прототип лишен возможностей по статическому анализу, имеющихся в PyCharm и
использует модуль стандартной библиотеки Python !ast! для построения абстрактных
синтаксических деревьев (\emph{abstract syntax tree} --- AST). Так как он был
написан преимущественно для сбора статистики в нем принимается ряд допущений:

\nomenclature{AST}{Abstract Syntax Tree}

\begin{itemize}
    \item{%
        Анализируемые программы не должны содержать синтаксических ошибок,
        поскольку в отличии от парсера PyCharm, модуль !ast! не способен
        разбирать такие программы.
      }
    \item{%
        Прототип не учитывает потока исполнения и алиасинга внутри функций, что
        может потенциально приводит к менее точным результатам.
      }
    \item{%
        Также прототип имеет ограниченные возможности по разрешению имен в проектах, в
        частности не учитывает условных и локальных импортов. В целом считается,
        что каждое имя внутри модуля объявлено только один раз.
      }
    \item{%
        Прототип не повторяет имеющуюся функциональность PyCharm по
        выводу типов параметров функций. В частности он не учитывает типы
        значений аргументов по-умолчанию, а также типы аргументов в местах
        вызова функции. 
      }
\end{itemize}

Также в прототипе первые два этапа работы алгоритма: индексация классов и поиск
атрибутов параметров функций объединены в одном проходе, а индексы в отличии от
PyCharm, не сохраняются на диск и перестраиваются при каждом запуске прототипа.

% \section{Описание алгоритмов}

% \subsection{Cartesian product algorithm}
% \label{sub:CPA}

% Ole Ageseen, один из разработчиков языка SELF в 1995 предложил алгоритм
% Cartesian Product Algorithm (CPA)~\cite{Agesen1995}, позволяющий выводить
% конкретные типы аргументов для полиморфных функций. Достигается это следующим
% образом.

% Сначала собирается вся первоначально доступная информация о типах выражений и
% переменных в программе и распространяется посредством анализа графа потока
% данных (Data Flow Graph --- DFG).  Затем для каждого случая вызова функции
% информация о возможных типах аргументов используется для вывода типа ее
% возвращаемого значения. Причем поскольку из-за динамической типизации аргумент
% может принимать значение одного из нескольких возможных типов, собирается
% декартово произведение множеств возможных типов аргументов и анализ происходит
% для каждого кортежа в отдельности (отсюда название алгоритма). Каждая из
% обнаруженных комбинаций типов аргументов анализируется один раз.

% Как отмечается в работе~\cite{Madsen2007} работы O. Agessen не раскрывают
% многих аспектов практического применения алгоритма, к тому же целевой язык SELF
% имеет ряд отличий от современных высокоуровневых динамически типизированных
% языков таких как Ruby или Python. Тем не менее с момента его создания CPA
% применялся в ряде различных проектов~\cite{Madsen2007,Salib2004,Hanov},
% посвященных выводу типов в языках с динамической типизацией, и зарекомендовал
% себя как достаточно точное и эффективное решение.
