%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Проектирование}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Описание алгоритма}

Как уже было отмечено, вывод типов параметров функций в настоящий момент
является в PyCharm проблемой решенной лишь частично. Представим следующую
функцию на Python:

\begin{lstlisting}
def slugify(s):
    return '-'.join(s.split())
\end{lstlisting}

Посмотрев на тело функции можно догадаться о ее назначении: разбиение строки на
слова с последующей конкатенацией их через дефис. Программист предполагает сигнату
функции \texttt{str -> str}. Естественно, что в условиях ``утиной
типизации'' в качестве аргумента может быть использован любой объект имеющий
метод !split()!, поэтому при отсутствии каких-либо явных аннотаций, например, в
формате системы документации Sphinx, PyCharm пессимистично считает тип аргумента
!s! неопределенным, однако выводит тип возвращаемого значения как !str!, потому
что тип стандартного метода !str.join(seq)! известен. Таким образом, тип функции
!slugify(s)! --- \texttt{(s: unknown) -> str}.

\begin{lstlisting}
def slugify(s):
    """
    :type s: str
    :rtype: str
    """
    return '-'.join(s.split())
\end{lstlisting}

Тип мог бы быть выведен из мест вызова функции, например, 
!slugify('foo bar baz')!, но, во-первых, с целью повышения быстродействия в
PyCharm используются только вызовы функции в том же модуле, где она объявлена,
а, во-вторых, это не поможет на этапе, когда функция только пишется, но
в этот момент наиболее полезным оказалось бы знание типа параметра !s!
средой разработки, например, для автодополнения других его методов, таких как,
!s.lower()!.

Идеей алгоритма предлагаемого в данной работе является сбор информации об
обращениях к методам и полям параметра (совместно называемых \emph{атрибутами})
функции в ее теле и последующий поиск подходящих по интерфейсу классов среди
известных. В целом алгоритм вывода типов для параметра функции работает в три этапа:

\begin{enumerate}
    \item{Первоначальная индексация проекта с целью поиска определений классов.
      Выполняется полностью только один раз.}
    \item{Поиск атрибутов параметра, к которым выполняется обращение в теле
        функции.}
    \item{Подбор номинальных типов, т.е. в случае Python --- классов, подходящих
      по интерфейсу.}
\end{enumerate}

Такой подход не является новым, и идеи использования структурных
типов для описания типов объектов уже высказывались в нескольких работах. 
Однако, например, в работе~\cite{Pluquet2009}, где такие типы называются
\emph{интерфейсными} (\emph{interface types}), описывается алгоритм поиска
классов в программах на Smalltalk, требующий первоначального построения единой
иерархии всех известных классов, что вступает в конфликт с описанным ранее
требованием инкрементальности, так как неясно, как подобную иерархию
можно инкрементально обновлять, тем более в условиях множественного наследования
в Python.  Авторы проекта Diamondback Ruby~\cite{Furr2009}, с другой стороны,
введя объектные типы (\emph{object types}) в свою систему типов, отказались от
идеи подбора подходящих классов, аргументируя это тем, что это разрушило бы
модульность их анализа.

\begin{quote}
  If we wanted to stick to nominal typing only, we could try to find all
  classes that have methods foo and bar, and then give x a type that
  is the union of all such classes. However, this would be both ex-
  tremely messy and non-modular, since changing the set of classes
  might require updating the type of f.
\end{quote}

Проблему неинкрементальности, или немодульности, поиска классов по атрибутам, к
которым происходит обращение можно проиллюстрировать на примере. Допустим, что
в программе на Python имеется четыре следующих определения:

\begin{lstlisting}
class A:
    def foo(self):
        pass

class B(A):
    def bar(self):
        pass

class C:
    def foo(self):
        pass


def func(x):
    x.foo()
    x.bar()

\end{lstlisting}

Для людей, незнакомых с синтаксисом Python, поясним, что в круглых скобках после
имени класса при его определении указываются идентификаторы его базовых классов
через запятую. Например, в данном случае класс !B! наследуется от !A!.

Так как !B! --- единственный класс в программе, в котором имеются методы !foo()! и
!bar()!, то он должен стать логичным результатом вывода типа параметра !x!
функции !func!. Однако метод !foo()! непосредственно к классе !B! не объявлен
и доступен ему через наследование от класса !A!. Поиск определения класса !A!
обычно включает процедуру разрешения имени (\emph{name resolution}), которая
требует использования индексов. Представим теперь, что все четыре
определения находятся в разных модулях программы, \emph{индексируемых
независимо}. Мы не можем совместить индексирование и разрешение имен, сохранив в
индексе для конкретного класса доступные ему атрибуты с учетом наследования.
Даже если бы это было возможно, например, через несколько проходов индексации,
изменение суперкласса --- класса !A! в данном случае --- потребовало бы изменения
содержимого индексов для всех его наследников, т.е. для класса !B!. 

Есть несколько решений данной проблемы. Одним из них является использование
только атрибутов, непосредственно определенных в теле класса. В этом случае
можно было бы либо подбирать только классы, в которых непосредственно определен
по крайней мере один из используемых на атрибутов параметра, либо подбирать
только те, где определены все сразу. Однако первый подход неизбежно привел бы к
большому числу в действительности неподходящих классов, например, класса !C! в
приведенном примере, а второй исключил наследование атрибутов вовсе и в примере
для параметра !x! не было бы найдено ни одного подходящего класса вовсе.

Другим решением является \emph{разрешение атрибутов при каждом поиске классов для
параметра функции}. В этом случае требование инкрементальности будет сохранено,
потому как индекс классов будет включать только атрибуты, определенные в них
непосредственно. Однако возникает вопрос о быстродействии такого решения,
особенно в контексте использования его в среде разработке. 

Разработанный алгоритм имеет в худшем случае сложность $O(n^2)$, где $n$ ---
количество классов в проекте. Однако на практике по результатам испытаний даже в
очень больших проектах, включающих тысячи определений классов и функций вывод
типов для всех параметров занимает доли секунды, что достигается за счет
кэширования всех найденных базовых классов в процессе классов по атрибутам.

\todo{Добавить псевдокод алгоритма}

Для проверки работоспособности данного алгоритма был написан прототип на
Python, позволивший собрать определенную статистику путем анализа нескольких
десятков открытых проектов, написанных на Python.

Прототип лишен возможностей по статическому анализу, имеющихся в
PyCharm и использует стандартный модуль !ast! для построения абстрактных
синтаксических деревьев (\emph{abstract syntax tree} --- AST). Так как он был
написан преимущественно для сбора статистики в нем принимается ряд допущений:

\nomenclature{AST}{Abstract syntax tree}

\begin{itemize}
    \item{%
        Анализируемые программы не должны содержать синтаксических ошибок,
        поскольку в отличии от парсера PyCharm, модуль !ast! не способен
        разбирать такие программы.
      }
    \item{%
        Прототип не учитывает потока исполнения и алиасинга внутри функций, что
        может привести к менее точным результатам.
      }
    \item{%
        Также прототип имеет ограниченные возможности по разрешению имен в проектах, в
        частности не учитывает условных и локальных импортов. В целом считается,
        что каждое имя внутри модуля объявлено только один раз.
      }
    \item{%
        Прототип не имеет не повторяет имеющуюся функциональность PyCharm по
        выводу типов параметров функций, в частности использования типов
        значений аргументов по-умолчанию.
      }
\end{itemize}

Также в прототипе первые два этапа работы алгоритма объединены в один, а индексы
в отличии от PyCharm, не сохраняются на диск и перестраиваются при каждом
запуске прототипа.

% \section{Описание алгоритмов}

% \subsection{Cartesian product algorithm}
% \label{sub:CPA}

% Ole Ageseen, один из разработчиков языка SELF в 1995 предложил алгоритм
% Cartesian Product Algorithm (CPA)~\cite{Agesen1995}, позволяющий выводить
% конкретные типы аргументов для полиморфных функций. Достигается это следующим
% образом.

% Сначала собирается вся первоначально доступная информация о типах выражений и
% переменных в программе и распространяется посредством анализа графа потока
% данных (Data Flow Graph --- DFG).  Затем для каждого случая вызова функции
% информация о возможных типах аргументов используется для вывода типа ее
% возвращаемого значения. Причем поскольку из-за динамической типизации аргумент
% может принимать значение одного из нескольких возможных типов, собирается
% декартово произведение множеств возможных типов аргументов и анализ происходит
% для каждого кортежа в отдельности (отсюда название алгоритма). Каждая из
% обнаруженных комбинаций типов аргументов анализируется один раз.

% Как отмечается в работе~\cite{Madsen2007} работы O. Agessen не раскрывают
% многих аспектов практического применения алгоритма, к тому же целевой язык SELF
% имеет ряд отличий от современных высокоуровневых динамически типизированных
% языков таких как Ruby или Python. Тем не менее с момента его создания CPA
% применялся в ряде различных проектов~\cite{Madsen2007,Salib2004,Hanov},
% посвященных выводу типов в языках с динамической типизацией, и зарекомендовал
% себя как достаточно точное и эффективное решение.
