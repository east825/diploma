%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Модульное тестирование}
\label{sec:unit-testing}
Модульное тестирование прототипа осуществлялось при помощи библиотеки pytest.
Тесты включают в себя разрешение имен, вывод пользовательских типов для
параметров и типов из стандартной библиотеки, форматирование и подсчет
статистических данных, а также работоспособность различных вспомогательных
функций, использовавшихся в проекте --- всего 24 теста. 

\section{Анализ открытых проектов}
\label{sec:projects-analysis}

Примеры статистики для нескольких проанализированных проектов приведены в
таблице~\ref{tab:statistic-results-1}

\begin{table}[H]
  \scriptsize
  \caption{Результаты анализа нескольких открытых проектов.}
  \label{tab:statistic-results-1}
  \begin{tabularx}{\textwidth}{ |X|X|X|X|X|X| }
    \hline
    Проект & Общее число классов/функций/параметров & Параметры без атрибутов &
    Параметры с атрибутами, но без выведенного типа & 
    Параметры с одним выведенным типом & 
    Параметры с несколькими выведенными типами \\ \hline

    Flask & 106/961/615 & 502 (81.63\%) & 7 (1.14\%) & 32 (5.20\%) & 74 (12.03\%)
    \\ \hline

    Django & 1696/7494/9530 & 7415 (77.81\%) & 186 (1.95\%) & 539 (5.66\%) &
    1390 (14.59\%)
    \\ \hline

    requests & 121/643/661 & 536 (81.09\%) & 11 (1.66\%) & 18 (2.72\%) & 96
    (14.52\%)
    \\ \hline

    youtube-dl & 420/1071/1201 & 1003 (83.51\%) & 12 (1.00\%) & 14 (1.17\%)
    & 172 (14.32\%)
    \\ \hline

    fn.py & 42/327/242 &  224 (92.56\%) & 2 (0.83\%) & 9 (3.37\%) & 7
    (2.89\%)
    \\ \hline

  \end{tabularx}
\end{table}

Также для сбора более репрезентативной статистики такой анализ был запущен на 63
случайных проектов, загруженных с Github. Результаты приведены в
таблице~\ref{tab:statistics-results-2}

\begin{table}[H]
  \scriptsize
  \caption{Результаты анализа выборки открытых проектов.}
  \label{tab:statistics-results-2}
  \begin{tabularx}{\textwidth}{ |X|X|X| }
    \hline
    Метрика & Среднее значение & Дисперсия \\ \hline
    Доля параметров без атрибутов & 0.807 & 0.006 \\ \hline
    Доля параметров с атрибутами, но без выведенного типа & 0.04 & 0.05 \\ \hline
    Доля параметров с одним выведенным типом & 0.051 & 0.001 \\ \hline
    Доля параметров с несколькими выведенными типами & 0.100 & 0.002 \\ \hline
    Максимальное число базовых классов при выводе & 4.121 & 5.470 \\ \hline
  \end{tabularx}
\end{table}

Как видно из приведенных результатов, доля параметров для которых находится по крайней
мере тип сравнительно высока (15\%).

\section{Точность вывода}
\label{sec:inference-precision}

Возможные ошибки алгоритма вывода типов параметров можно разделить на две категории:
\begin{description}
    \item[Ошибки типа \emph{false positive}] выражаются в том, что для параметра
      будут найдены неправильные классы, которые в
      действительности не подходят для передачи в функцию.    

    \item[Ошибки типа \emph{false negative}] выражаются в том, что для параметра
      не будут подобраны классы.

\end{description}

Рассмотрим подробнее различные источники этих ошибок.

\subsection{Параметры без обращений к атрибутам}
\label{sub:attributeless-parameters}

Одним из вариантов ошибки типа false negative, является случай, при котором для
переменной не было выведено ни одного типа вообще.  Как видно из результатов
анализа открытых проектов доля таких параметров высока, главным образом, потому
что ко многим из них не происходит обращений. В текущем виде алгоритм не
позволяет решить найти типы для таких параметров, поскольку без какой-либо
информации о структурном типе нельзя подобрать подходящий номинальный.
Существует несколько вариантов решения этой проблемы. 

Одним из них является учет специальных методов (\emph{special methods}). Это
увеличит количество информации об атрибутах, потому что в Python и ряде других
динамически типизированных языков перегрузка использования операторов происходит
посредством перегрузки специальных функций.  Например, в
листинге~\ref{lst:plus-overloading} приведен пример перегрузки оператора
сложения !+! для класса !TextRange!.

\begin{lstlisting}[
  caption={Пример перегрузки оператора в Python.},
  label={lst:plus-overloading}
]
class TextRange:
    def __init__(self, x, y):
        if y < x or x < 0:
            raise ValueError('Illegal range: must be y >= x && x >= 0')
        self.x = x
        self.y = y

    def __add__(self, other):
        if not isinstance(other, TextRange):
            return NotImplemented
        return TextRange(min(self.x, other.x), max(self.y, other.y))

def union_range(r1, r2):
    return r1 + r2    

\end{lstlisting}

Для приведенного примера можно было бы вывести, что для параметров функции
!union_range!: !r1! и !r2! подходящий класс обязательно должен иметь
переопределенный метод !__add__!. 

В Python имеются и другие конструкции, использование которых подразумевает
наличие у объекта переопределенных специальных методов, например, для
использования в цикле !for! у класса объекта должен быть переопределен метод
!__iter__!. Однако не все такие случаи могут быть использованы для вывода типов
на практике. Например, пользовательский класс может переопределить поведение в,
так называемом, логическом контексте (\emph{boolean context}) через метод
!__bool__!. Если в классе данный метод не определен, используется метод
!__len__!. Если не определен и он, то любой объект принимается за истинное
значение
(!True!)\footnote{\url{https://docs.python.org/3.3/reference/datamodel.html\#object.\_\_bool\_\_}}.

Другим способом получения дополнительной информации об атрибутах является
использование информации от функций, в которые передается значение параметра в
качестве аргумента. Такой способ должен существенно повысить качество вывода,
однако связан с рядом трудностей. В частности с разрешением этих функций,
например, если вызывается метод одного из других параметров. Пример такой
неопределенности при выводе типов показан в
листинге~\ref{lst:called-function-ambiguity}.

\begin{lstlisting}[
  caption={Неопределенность при использовании информации из вызываемых
    функций.},
  label={lst:called-function-ambiguity}
]
class A:
    def foo(self, x):
        x.bar()

class B:
    def foo(self, x):
        x.baz()

def func(x, y):
    x.foo(y)
\end{lstlisting}

Какой тип в этом случае у параметра !y! функции !func!: $\{bar\}$, $\{baz\}$,
$\{bar, baz\}$ или $\{\}$? Одним из путей решения данной проблемы является
использование этого способа только в том случае, если функция точно определена,
т.е. является, например, стандартной функцией или --- для методов --- другим
методом того же класса (вызвана на параметре !self!).

Наконец, даже если параметр функции не был использован ни в качестве операнда,
ни в качестве аргумента, а был, например, сразу возвращен, такую функцию можно
расценивать, как использующую параметрический полиморфизм. Примером, такой
функции является уже приводившаяся ранее в листинге~\ref{lst:identity-function}
функция-идентичности, тип которой $(a) \rightarrow a$.

\subsection{Параметры с неопределенным типом}
\label{sub:undefined-type-parameters}

Другую группу ошибок типа false negative представляют параметры, у которых
имеются атрибуты к которым происходит обращение, но не было выведено ни одного
типа. Анализ нескольких таких случаев показал, что это может произойти по
следующим причинам:

\begin{enumerate}
    \item Необходимый класс не был проиндексирован, например, из-за того, что
      проектная зависимость не была включена в анализ.

    \item Атрибут класса был выставлен при помощи метапрограммных средств языка,
      например, через метаклассы, функцию !setattr(obj, name, value)! или просто
      вне конструктора, что не поддерживается в прототипе и потому он не был
      включен в индекс.

    \item Не учитывающий поток исполнения алгоритм поиска атрибутов параметра
      привел к созданию структурного типа, включающего слишком много
      атрибутов, и с которым поэтому не совместим ни один класс.

\end{enumerate}

\todo{Примеры, примеры}

\subsection{Параметры с единственным выведенным типом}
\label{sub:single-type-parameters}

Если для параметра был выведен ровно один подходящий тип, и он был найден
неправильно, это является как ошибкой типа false positive, так и ошибкой типа
false negative. Выборочная проверка таких параметров показала, что доля неверных
результатов невысока. Например, из нечувствительности анализа к потоку
управления, может быть найден более общий тип.

\section{Быстродействие}
\label{sec:inference-performance}
