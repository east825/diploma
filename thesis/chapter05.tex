%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Анализ результатов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Собираемая статистика}
\label{sec:statistics-collecting}

Главной задачей, ставившейся при разработке прототипа, была оценка эффективности
предлагаемого метода для вывода типов параметров функций и его применимости в
среде разработки PyCharm. Для того, чтобы оценить такие характеристики
разработанного метода, как его точность и полнота, прототипом собиралась
следующая статистика:

\begin{enumerate}
  \item Количество проиндексированных модулей ($N_m$), классов ($N_c$), функций
    ($N_f$) и параметров ($N_p$) только в проекте (без зависимостей и
    стандартной библиотеки) и в целом.

  \item Параметры функций, содержащие максимальное число уникальных атрибутов, к
    которым происходило обращение.

  \item Число параметров функций, к атрибутам которых не происходило обращений в
    теле функции (\emph{attributeless parameters}) --- $N_{ap}$.
    Поскольку для параметров без использованных атрибутов наш алгоритм,
    очевидно, не может подобрать каких-либо классов, для этих параметров также
    собиралась дополнительная информация:
    
    \begin{enumerate}
        \item сколько из них используются в качестве аргументов функций
        \item сколько из них используются с арифметическими и битовыми операторами
        \item сколько из них используются в качестве возвращаемого значения функции
    \end{enumerate}

  \item Число параметров функций, к атрибутам которых происходило обращение, но для
    которых не было найдено ни одного подходящего класса (\emph{undefined
      parameters}) --- $N_{up}$.

  \item Число параметров функций, к атрибутам которых происходило обращение, и для
    которых был найден только один подходящий класс (\emph{exact type parameters}) 
    --- $N_{etp}$.

  \item Число параметров функций, к атрибутам которых происходило обращение, и для
    которых было найдено более одного подходящего класса (\emph{scattered type
      parameters}) --- $N_{stp}$.

\end{enumerate}

Все четыре последние группы параметров для чистоты измерений включают только
параметры функций, входящих в проект, без исключенного первого параметра !self!
не статических методов классов. Для каждой из групп также измерялось
отношение числа входящих в нее параметров к общему числу параметров
проиндексированных в проекте.
Обозначим эти отношения как $R_{ap} = \frac{N_{ap}}{N_p}$, $R_{up} =
\frac{N_{up}}{N_p}$ и т.д.

Значения снятых метрик для нескольких из проанализированных проектов приведены в
таблице~\ref{tab:statistic-results-1}.

\begin{table}[H]
  \small
  \caption{Результаты анализа нескольких открытых проектов}
  \label{tab:statistic-results-1}
  \begin{tabularx}{\textwidth}{ |X|X|X|X|X|X|X|X| }
    \hline
    \multicolumn{1}{|c|}{\multirow{2}{*}{}} &
    \multicolumn{3}{c|}{Определения} &
    \multicolumn{4}{c|}{Параметры}
    \\ \cline{2-8}
    & $N_c$ & $N_f$ & $N_p$ & $R_{ap}$ & $R_{up}$ & $R_{etp}$ & $R_{stp}$ 
    \\ \hline

    Flask & 106 & 961 & 615 & 81.63\% & 1.14\% & 5.20\% & 12.03\%
    \\ \hline

    Django & 1696 & 7494 & 9530 & 77.81\% & 1.95\% & 5.66\% & 14.59\%
    \\ \hline

    requests & 121 & 643 & 661 & 81.09\% & 1.66\% & 2.72\% & 14.52\%
    \\ \hline

    youtube-dl & 420 & 1071 & 1201 & 83.51\% & 1.00\% & 1.17\% & 14.32\%
    \\ \hline

    fn.py & 42 & 327 & 242 & 92.56\% & 0.83\% & 3.37\% & 2.89\%
    \\ \hline

    % Flask & 106 & 961 & 615 & 502 (81.63\%) & 7 (1.14\%) & 32 (5.20\%) & 74 (12.03\%)
    % \\ \hline

    % Django & 1696/7494/9530 & 7415 (77.81\%) & 186 (1.95\%) & 539 (5.66\%) &
    % 1390 (14.59\%)
    % \\ \hline

    % requests & 121/643/661 & 536 (81.09\%) & 11 (1.66\%) & 18 (2.72\%) & 96
    % (14.52\%)
    % \\ \hline

    % youtube-dl & 420/1071/1201 & 1003 (83.51\%) & 12 (1.00\%) & 14 (1.17\%)
    % & 172 (14.32\%)
    % \\ \hline

    % fn.py & 42/327/242 &  224 (92.56\%) & 2 (0.83\%) & 9 (3.37\%) & 7
    % (2.89\%)
    % \\ \hline

  \end{tabularx}
\end{table}

Отметим, что число параметров функций может быть меньше количества функций,
потому что, во-первых, часть функций не имеет параметров, а, во-вторых, первые
параметры !self! и !cls! для не статических методов классов исключались из
рассмотрения (раздел~\ref{sec:prototype-limits}).

Нас также интересовали средние значения относительных размеров групп: $\bar{R}_{ap}$,
$\bar{R}_{up}$, $\bar{R}_{etp}$ и $\bar{R}_{stp}$. Для получения более
репрезентативных результатов с хостинга Github было загружено 100 проектов на
Python с открытыми исходными текстами размером не более 30 Мб. Из них были
исключены проекты, содержащие малое число модулей на Python, имеющие большое
число зависимостей или сложную структуру проекта, препятствующую их анализу в
автоматическом режиме. 

Средние значения, полученные для оставшихся 66 проектов приведены в
таблице~\ref{tab:statistics-results-2}.

\begin{table}[H]
  \small
  \caption{Средние значения размеров групп параметров (в процентах) по проектам}
  \label{tab:statistics-results-2}
  \centering
  \begin{tabularx}{0.5\textwidth}{ |X|X| }
    % \hline
    % & Мат. ожидание & Ср. кв. отклонение 
    % \\ \hline

    \hline
    $\bar{R}_{ap}$ & 81.02\% \\ \hline

    $\bar{R}_{up}$ & 3.26\% \\ \hline

    $\bar{R}_{etp}$ & 3.24\% \\ \hline

    $\bar{R}_{stp}$ & 12.48\% \\ \hline

  \end{tabularx}
\end{table} 

Рассмотрим теперь, как эти данные позволяют нам оценить искомые характеристики
эффективности предлагаемого решения.

В разделе~\ref{sec:precision-requirement} обсуждались характеристики точности
(soundness) и полноты (completeness) статического анализа, а также ставилось
требование достижения наибольшей точности при, по возможности, наибольшей
полноте для используемых в составе IDE методов анализа программ. Поскольку
оценки полноты и точности рассчитываются через количество ложноположительных
(false-positive) и ложноотрицательных (false-negative) программных дефектов,
полученных в результате анализа, поясним сначала, какие ошибки, могут быть
найдены нашим методом.  Так как предлагаемый в работе алгоритм позволяет
находить точные типы параметров функций в программах на Python, потенциально он
позволяет предотвратить ошибку использования аргумента неправильного типа.
Следовательно, если нашим методом будут выведены такие типы для параметра, из-за
которых будет считаться ошибкой передача в функцию правильных аргументов,
пострадает точность, если же, наоборот, мы пропустим передачу аргументов
неправльного типа, упадет полнота.

Первые две группы параметров ($N_{ap}$ и $N_{up}$), для которых мы не смогли
вывести ни одного типа, позволяют нам оценить верхнюю границу значения полноты
анализа. Действительно, пусть типом всех параметров, для которых мы не подобрали
ни одного типа, считается !object!. Это не может привести к ложным сообщениям об
ошибках, потому что в Python любое значение, в том числе целые числа и
логические константы, считается экземпляром !object!. Однако каждый такой случай
уменьшает полноту анализа, так как исключает возможность предотвратить
потенциальный программный дефект. Таким образом, значение полноты можно оценить
как

\[
  C \le 1 - (\bar{R}_{ap} + \bar{R}_{up}) = \bar{R}_{etp} +
  \bar{R}_{stp} = 0.032 + 0.124 \approx 15.6\%
\]

Это значение полноты относительно всех параметров, для которых выводились типы
нашим методом, т.е. без первого параметра методов, не аннотированных как
!@staticmethod! (раздел~\ref{sec:prototype-limits}). Можно также рассчитать
значение полноты по средним значениям относительно \emph{всех} параметров в
проекте.

\[
  C_{all~parameters} \le \bar{R'}_{etp} + \bar{R'}_{stp} = 0.02 + 0.082 \approx 10.3\% 
\]

Здесь для каждого из проектов значения $R'_{etp}$ и $R'_{stp}$ рассчитываются
как:

\[
  R'_{etp} = R_{etp}
  \frac{N_{indexed~project~parameters}}{N_{all~project~parameters}} = R_{etp}
  \frac{N_p}{N_{all~project~parameters}}
\]
\[
  R'_{stp} = R_{stp}
  \frac{N_{indexed~project~parameters}}{N_{all~project~parameters}} = R_{stp}
  \frac{N_p}{N_{all~project~parameters}}
\]

В среднем значение коэффициента $N_p / N_{all~project~parameters}$ составило
65\%, т.е. как минимум для 35\% других параметров функций типы в PyCharm будут
точно известны.

Также приведем значение полноты относительно всех выражений в проектах. Это
приближенное значение, потому что без чувствительного к потоку исполнения
алгоритма нельзя точно подсчитать число чтений значений параметров в
теле функции.

\[
  C_{all~expressions} \le \bar{R''}_{etp} + \bar{R''}_{stp} = 0.002
  + 0.008 \approx 1\% 
\]

Значения $R''_{etp}$ и $R''_{stp}$ для проектов рассчитывались как:
\[
  R''_{etp} = R_{etp}
  \frac{N_{indexed~project~parameter~references}}{N_{project~expressions}}
\]
\[
  R''_{stp} = R_{stp}
  \frac{N_{indexed~project~parameter~references}}{N_{project~expressions}}
\]

Среднее значение коэффициента, представляющего отношение числа чтений значений
проиндексированных параметров функций к общему числу выражений в проекте,
составило 7\%.

Следует отметить, что данные оценки не учитывают существования функций и
методов, для которых тип параметра !object! является верным, т.е.  которые в
действительности могут принимать аргументы произвольного типа (например,
стандартная функция !str!). Мы считаем, однако, что доля таких полиморфных
функций в действительности чрезвычайно мала, в частности нам их не встретилось
ни одной такой функции при ручной проверке результатов вывода, описанной в
главе~\ref{sec:precise-analysis}.

В отличие от полноты, точность анализа нельзя оценить без знания о том, какие в
действительности значения параметров ожидает функция. В
разделе~\ref{sec:precise-analysis} приведены результаты более подробного анализа
результатов вывода типов параметров в рассмотренных проектах.

\section{Оценка характеристик алгоритма}
\label{sec:precise-analysis}

На практике существует четыре возможных результата вывода типов для параметра,
которые по-разному влияют на точность и полноту анализа.

\begin{description}

  \item[Точные и полные результаты] \hfill \\
    Если в результате вывода типа параметра был найден один или несколько
    классов, каждый из которых является правильным, такой результат считается и
    точным, и полным, потому что не может привести ни к пропущенным, ни к ложным
    ошибкам.
    
  \item[Точные, но неполные результаты] \hfill \\
    Если в результате вывода типов было найдено несколько классов, только часть
    из которых является правильными, или был выведен более общий тип
    (суперкласс), чем нужно, то такой результат не уменьшит точности анализа,
    однако негативно скажется на его полноте, потому что появится возможность
    пропустить ошибку передачи в функцию неправильного аргумента.

  \item[Неточные, но полные результаты] \hfill \\
    Такой случай возможен, если для параметра было выведено меньше подходящих
    классов, чем возможно на самом деле, или, если был выведен более частный тип
    (подкласс). Сразу отметим, что таких ситуаций среди рассмотренных
    встретилось меньше всего.

  \item[Неточные и неполные результаты] \hfill \\
    Такой вариант имеет место, если все классы, подобранные для параметра, один
    или несколько, являются неверными.

\end{description}

Для оценки полноты анализа мы случайным образом выбрали 100 параметров функций
из 66 проанализированных проектов, для которых было выведено один или несколько
типов, и, вручную оценив корректность выведенных типов, сгруппировали их по
четырем описанным категориям. Полученные результаты приведены в
таблице~\ref{tab:manual-analysis-results}.

\begin{table}[H]
  \small
  \centering
  \caption{Результаты ручной оценки качества вывода типов}
  \label{tab:manual-analysis-results}
    \begin{tabularx}{0.7\textwidth}{|X|X|}
      \hline
      Тип результата & Количество случаев 
      \\ \hline 
      Точные и полные & 38
      \\ \hline
      Точные и неполные & 44 
      \\ \hline
      Неточные и полные & 2
      \\ \hline
      Неточные и неполные & 16
      \\ \hline
    \end{tabularx}
\end{table}

Таким образом, экспериментально оцененная точность анализа составляет 82\%, а
полнота --- 40\% от полученных ранее оценок, а именно 6.24\%  от общего числа
проанализированных параметров функций. Различные случаи ошибок в каждой
из трех последних категорий рассматриваются в следующем разделе.

\section{Ошибки анализа}
\label{sec:analysis-errors}

% Первые две группы параметров: параметры без атрибутов и параметры с атрибутами,
% для которых не было подобрано подходящих классов, объединяют случаи, где тип
% параметра остался неопределенным, что позволяет нам оценить верхнюю границу
% полноты нашего метода.


% Эта оценка полноты только для вывода типов значений параметров функций. Для
% оценки полноты метода относительно всех выражений в программе необходимо
% домножить ее на среднее значение отношения числа параметров к числу выражений в
% программе.

% Низкая полнота анализа не является проблемой, потому что, напомним, предложенный
% метод разрабатывается в качестве дополнения к имеющейся функциональности среды
% PyCharm, которая покрывает значительную часть других случаев: тип параметра
% !self!, типы аргументов со значениями по-умолчанию, а также типы некоторых
% локальных переменных.

% \subsection{Оценка точности}
% \label{sub:soundness-estimate}

% Для оценки точности анализа мы использовали следующий подход. Среди параметров в
% рассмотренных проектах, попадающих в последние две группы: параметры, для
% которых был выведен только один класс, и параметры, для которых было найдено
% более одного класса, было взято 100 случайных, корректность вывода типа для
% которых была проверена вручную.



% % Как видно из приведенных результатов, даже при большом числе допущений,
% % принятых в прототипе доля параметров для которых находится по крайней мере тип
% % не так высока (15\%).  Однако следует учитывать, что в прототипе не используются
% % имеющиеся возможности по выводу типов в PyCharm, перечисленные в
% % подразделе~\ref{sec:compatibility-requirement}.  Пути повышения точности анализа
% % обсуждаются в следующем разделе~\ref{sec:inference-precision}.

% \section{Точность вывода}
% \label{sec:inference-precision-analysis}

% Возможные ошибки алгоритма вывода типов параметров можно разделить на две категории:
% \begin{description}
    % \item[Ошибки типа \emph{false positive}] выражаются в том, что для параметра
      % будут найдены неправильные классы, которые в
      % действительности не подходят для передачи в функцию и могут привести к
      % ошибке во время исполнения.

    % \item[Ошибки типа \emph{false negative}] выражаются в том, что для параметра
      % не будут найдены подходящие классы, несмотря на то, что такие классы
      % определены в проекте или библиотеках, от которых он зависит.

% \end{description}

% Рассмотрим подробнее различные источники этих ошибок.

\subsection{Параметры без обращений к атрибутам}
\label{sub:attributeless-parameters}

Самым большим ограничением полноты анализа на данный момент являются параметры
функций, к атрибутам которых не происходит обращений, которых, напомним,
оказалось в среднем 81\% от всех проиндексированных.

Одним из возможных решений является учет при подборе типов, так называемых,
специальных методов (\emph{special
  methods})\footnote{\url{https://docs.python.org/3.4/reference/datamodel.html\#special-method-names}}. Например,
в Python и ряде других динамически типизированных языков путем переопределения
специальных методов осуществляется перегрузка операторов.  Так, в
листинге~\ref{lst:plus-overloading} приведен пример перегрузки оператора
сложения ``+'' для класса !TextRange!.

\begin{lstlisting}[
  caption={Пример перегрузки оператора в Python},
  label={lst:plus-overloading}
]
сlass TextRange:
    def __init__(self, x, y):
        if y < x or x < 0:
            raise ValueError('Illegal range: must be y >= x && x >= 0')
        self.x = x
        self.y = y

    def __add__(self, other):
        if not isinstance(other, TextRange):
            return NotImplemented
        return TextRange(min(self.x, other.x), max(self.y, other.y))

def union_range(r1, r2):
    return r1 + r2    

\end{lstlisting}

Для приведенного примера можно было бы вывести, что для параметров функции
!union_range!: !r1! и !r2! подходящий класс обязательно должен иметь
переопределенный метод !__add__!. 

В Python имеются и другие конструкции, использование которых означает
наличие у объекта переопределенных специальных методов, например, для
использования в цикле !for! у класса объекта должен быть переопределен метод
!__iter__!. Однако не все такие случаи могут быть использованы для вывода типов
на практике. Например, пользовательский класс может переопределить поведение в,
так называемом, логическом контексте (\emph{boolean context}) через метод
!__bool__!. Если в классе данный метод не определен, используется метод
!__len__!, а если он также не найден, то любой объект принимается за истинное
значение
(!True!)\footnote{\url{https://docs.python.org/3.3/reference/datamodel.html\#object.\_\_bool\_\_}},
что часто используется для проверки того, содержит ли переменная значение
!None!. Таким образом, использование параметра в условном операторе не означает
наличие у класса перегруженного метода !__bool__!.

Собранная нами статистика показала, что в среднем 8.6\% параметров функций, к
атрибутам которых не происходит обращения, используются тем не менее в качестве
операндов бинарных и арифметических операторов.

Следует отметить, что в прототипе уже сейчас учитываются некоторые специальные
методы в Python: !__getitem__!, !__setitem__! и !__delitem__!,
которые вызываются при использовании оператора взятия элемента по индексу/ключу,
например, !xs[42]! или !map['key']!, а также !__init__!, в котором определяется
конструктор класса.

Другим способом получения дополнительной информации об атрибутах является
использование информации от функций, в которые передается значение параметра в
качестве аргумента. Такой способ должен существенно повысить качество вывода, за
счет учета большего количества дополнительных атрибутов, однако связан с рядом
трудностей. В частности существует неоднозначность определения функции,
например, если вызывается метод одного из других параметров. Пример такой
неопределенности при выводе типов показан в
листинге~\ref{lst:called-function-ambiguity}.

\begin{lstlisting}[
  caption={Неопределенность при использовании информации из вызываемых
    функций},
  label={lst:called-function-ambiguity}
]
class A:
    def foo(self, x):
        x.bar()

class B:
    def foo(self, x):
        x.baz()

def func(x, y):
    x.foo(y)
\end{lstlisting}

В приведенном примере неясно, какие из атрибутов !bar! и !baz! должен содержать
структурный тип параметра !func.y!, потому что в качестве типа параметра
!func.x! подходят классы !A! и !B!. Одним из путей решения данной проблемы
является использование этого способа только в том случае, если вызываемая функция точно
известна, т.е. является, например, стандартной функцией или --- при выводе
типов параметров методов --- другим методом того же класса (вызвана на параметре
!self!). Другим возможным решением является расчет пересечения множеств
атрибутов, используемых во всех возможных вариантах вызываемой функции.

Собранная статистика показывает, что в среднем 54.8\% параметров, к атрибутам
которых не происходит обращения в теле функции, используются в качестве
аргумента другой функции.

Наконец, даже если параметр функции не был использован ни в качестве операнда,
ни в качестве аргумента, а был, например, сразу возвращен, такую функцию можно
расценивать, как использующую параметрический
полиморфизм. Примером, такой функции является уже приводившаяся ранее в
листинге~\ref{lst:identity-function} функция-идентичности, типом которой
является $(a) \rightarrow a$. Параметров без атрибутов, используемых в качестве
возвращаемого значения функции среди рассмотренных проектов оказалось 1.4\%.

\subsection{Параметры с неопределенным типом}
\label{sub:undefined-type-parameters}

Другую группу параметров, из-за которых падает полнота анализа, представляют
параметры, к атрибутам которых происходит обращение, но для них не было выведено
ни одного типа. Напомним, что таких случаев среди рассмотренных проектов было в
среднем 3.3\%. Рассмотрение нескольких таких случаев показало, что это может произойти
по следующим причинам:

\begin{enumerate}
    \item Необходимый класс не был проиндексирован, например, из-за того, что
      проектная зависимость не была включена в анализ.

    \item Атрибут класса был определен при помощи метапрограммных средств языка,
      например, через метаклассы, функцию !setattr! или просто
      вне конструктора, что не поддерживается в прототипе, и потому этот класс не был
      найден в процессе вывода типов.

    \item Не учитывающий поток исполнения алгоритм поиска атрибутов параметра
      привел к созданию структурного типа, включающего слишком много
      атрибутов, с которым не совместим ни один класс.

\end{enumerate}

Для иллюстрации второго случая можно привести такой пример. В проекте
pep8\footnote{\url{https://github.com/jcrocholl/pep8}} для разбора аргументов
командной строки используется стандартный модуль !optparse!, частью интерфейса
которого является класс !OptionParser!. Этот класс содержит методы, такие как
!add_option! или !parse_args!, 
предназначенные для упрощения описания и разбора аргументов командной строки
приложения. Экземпляр класса !OptionParser! передается в качестве аргумента в
несколько функций !pep8!, однако несмотря на наличие атрибутов, однозначно
идентифицирующих этот класс, для соответствующих параметров он не был выведен.
Например, в функции !pep8.process_options(arglist, parse_argv, config_file, parser)!
происходит обращение к атрибутам параметра
!parser!: !has_option!, !parse_args!, !error! и !config_options!. Первые три из
них определены непосредственно в классе !OptionParser! или в его суперклассе
!OptionContainter!, однако последний --- !config_options! --- добавляется к
экземпляру !OptionParser! вне модуля !optparse! в функции
!pep8.get_parser(prog, version)!, фрагмент которой приведен в
листинге~\ref{lst:pep8-get_parser}. Это приводит к тому, что класс
!OptionParser! не расценивается как подходящий по структуре для параметра
!parser!.

\begin{lstlisting}[
  caption={Фрагмент функции \texttt{pep8.get\_parser}}, 
  label={lst:pep8-get_parser} 
]
def get_parser(prog='pep8', version=__version__):
    parser = OptionParser(prog=prog, version=version,
                          usage="%prog [options] input ...")
    parser.config_options = [
        'exclude', 'filename', 'select', 'ignore', 'max-line-length',
        'hang-closing', 'count', 'format', 'quiet', 'show-pep8',
        'show-source', 'statistics', 'verbose']
    ...
\end{lstlisting}

В другой функции в том же проекте --- 
!pep8.read_config(options, args, arglist, parser)!
--- для параметра !parser!
класс !OptionParser! также не выводится: на этот раз из-за обращения к атрибуту
!options_list!, который инициализируется не в конструкторе !OptionParser!, а в
методе !_create_options_list!, вызываемом в конструкторе его суперкласса,
из-за чего он также не учитывается нашим алгоритмом.



\subsection{Параметры с точным, но неполным результатом вывода}
\label{sub:sound-incomplete}

Такая ситуация возникает, если для параметра был выведен более общий тип, чем
нужно, либо несколько, из которых только один является подходящим. Вариантов с
неверно выведенным супертипом нам не встретилось, и все 44 найденных в ходе
ручной проверки случая точных, но неполных результатов были связаны с тем, что в
проекте и его зависимостях находилось больше подходящих классов, чем нужно. В 31
из этих случаев проблему вызывал метод !__getitem__!, означающий, что в теле
функции происходит обращение к параметру через оператор индексации. Для таких
параметров в отсутствие каких-либо других атрибутов находились, как
минимум, несколько коллекций стандартной библиотеки !list!, !tuple! и !dict!, а
также байтовые (!bytes!), и unicode-строки (!str!), также поддерживающие доступ
к элементам по индексу. В Django, например, в случае единственного атрибута
!__getitem__! для параметра находилось 60 классов с таким методом, из которых в
действительности мог быть использован только один. К другим часто используемым
именам атрибутов, определенным в независимых классах, относятся !name! и !read!. 

Не всегда, однако, вывод нескольких возможных классов означает, ошибку полноты.
Например, использование характерных для строк в Python методов, таких как
!strip! или !split!  приводит к выводу трех возможных типов !unicode!, !str! и
!bytearray! (в Python 2), все из которых в большинстве случаев оказываются
допустимыми.

Для этой проблемы также возможно несколько потенциальных решений. Во-первых, как
и в случае с параметрами без обращений к атрибутам, число возвращаемых классов
может уменьшить дополнительная информация об использовании значения параметра,
например, со стандартными операторами. Так, метод !__add__! в Python определен
для класса !list!, но не !dict!, поэтому при использовании параметра
!x! как !x + x[0]!, во множестве предлагаемых для него классов !dict! уже не будет.

Конкретно в случае метода !__getitem__!, исключать неподходящие коллекции можно
и по другим критериям, например, по типу значения которое используется в
качестве ключа. Если индексация выглядит как !x['foo']!, то ни строки, ни списки
не могут быть подходящими типами параметра, так как известно, что допустимым
значением индекса для них являются только целые числа. 

Еще одним способом исключения неподходящих коллекций является анализ типа
перехватываемых исключений в блоке \texttt{try/except}, окружающем обращение по
ключу. Например, в проекте
beets\footnote{\url{https://github.com/sampsyo/beets}} в классе
!ListStorageStyle! определен метод !fetch!, приведенный в
листинге~\ref{lst:beets-fetch}.

\begin{lstlisting}[
  caption={Перехват исключения при обращении по индексу},
  label={lst:beets-fetch}
]
def fetch(self, mutagen_file):
    """Get the list of raw (serialized) values.
    """
    try:
        return mutagen_file[self.key]
    except KeyError:
        return []
    
\end{lstlisting}

Известно, что при ошибке обращения по индексу некоторые стандартные коллекции
Python, такие как !tuple! и !list!, бросают исключение типа !IndexError!, а
!dict! и его наследники --- !KeyError!. Это также может быть использовано для
того, чтобы исключить часть неподходящих вариантов из множества предлагаемых
классов.

\subsection{Параметры с полным, но неточным результатом вывода}
\label{sub:unsound-complete}

Среди рассмотренных параметров таких случаев было лишь два, и в оба раза
неверный тип был выведен из-за использования динамических возможностей языка.
Первым из них является метод !MTurkConnection.duration_as_seconds! проекта 
boto\footnote{\url{https://github.com/boto/boto}},
приведенный в листинге~\ref{lst:boto-duration_as_seconds}.

\begin{lstlisting}[
  caption={Метод \texttt{MTurkConnection.duration\_as\_seconds}},
  label={lst:boto-duration_as_seconds}
]
@staticmethod
def duration_as_seconds(duration):
    if isinstance(duration, datetime.timedelta):
        duration = duration.days * 86400 + duration.seconds
    try:
        duration = int(duration)
    except TypeError:
        raise TypeError("Duration must be a timedelta or int-castable, got %s" % type(duration))
    return duration
\end{lstlisting}

Как видно из определения, в функцию может быть передано как значение класса
!datetime.timedelta!, так и любое значение, которое можно передать в стандартную
функцию !int!, например, строка, содержащая представление числа в десятичной
системе счисления, целое число или число с плавающей точкой. Нашим
алгоритмом однако был найден лишь класс !datetime.timedelta! по обращениям к
атрибутам !days! и !seconds! в теле метода. Следовательно, вызов данного метода
как !x = MTurkConnection.duration_as_seconds(100)!, будет расценен как
ошибочный, что неверно и приводит к падению точности.

\newpage

Другим вариантом ошибки такого рода является метод !ShellCommandTrick.on_any_event!
проекта watchdog\footnote{\url{https://github.com/gorakhargosh/watchdog}}. Его
фрагмент приведен в листинге~\ref{lst:watchdog-on_any_event}.

\begin{lstlisting}[
  caption={Фрагмент метода \texttt{ShellCommandTrick.on\_any\_event}},
  label={lst:watchdog-on_any_event}
]
def on_any_event(self, event):
    ...

    if self.shell_command is None:
        if has_attribute(event, 'dest_path'):
            context.update({'dest_path': event.dest_path})
            command = 'echo "${watch_event_type} ${watch_object} from ${watch_src_path} to ${watch_dest_path}"'
        else:
            command = 'echo "${watch_event_type} ${watch_object} ${watch_src_path}"'
    else:
        if has_attribute(event, 'dest_path'):
            context.update({'watch_dest_path': event.dest_path})
        command = self.shell_command

   ... 
\end{lstlisting}

В теле метода происходит обращение к атрибуту параметра !event! !dest_path!
после проверки наличия этого атрибута посредством функции !has_attribute!.
Нечувствительный к потоку исполнения алгоритм поиска атрибутов параметров в
прототипе считает этот атрибут обязательным, и в результате с учетом еще
нескольких использованных атрибутов находится единственный подходящий класс в
проекте --- !FileSystemMovedEvent!, тогда как на самом деле правильным типом
является его суперкласс !FileSystemEvent!, в котором нет атрибута !dest_path!.
Это означает, что при попытке передать в метод экземпляр другого
класса-наследника !FileSystemEvent!, например !FileDeletedEvent! мы сообщим о
ложной ошибке, что уменьшает точность разработанного нами метода и крайне
нежелательно в IDE.

Логичным решением данной проблемы является использование при анализе алгоритма
чувствительного к потоку управления и учет только тех параметров, обращение к
которым происходит на всех возможных путях исполнения в теле метода. В таком
случае, однако, мы не сможем вывести тип !datetime.timedelta! для ранее
рассмотренного метода !MTurkConnection.duration_as_seconds!, так как атрибуты
!seconds! и !days! окажутся неучтенными. Тем не менее подобные условные обращения
к атрибутам могут привести и к тому, что для параметра не будет найден вообще ни
один подходящий класс. 

В целом, использование чувствительного к потоку алгоритма поиска
атрибутов является интересным направлением для дальнейшего развития
предлагаемого метода.

\subsection{Параметры с неправильным типом}
\label{sub:unsound-incomplete}

Последнюю категорию ошибок вывода представляют параметры, для которых был найден
один или несколько типов, ни один из который в действительности не является
подходящим. Причины для этого такие же, как и в предыдущих случаях:
не проиндексированные зависимости проекта, использование динамических
возможностей в языке и нечувствительный к потоку исполнения алгоритм поиска
атрибутов параметров и классов, использованный в прототипе. 

% Например, некоторые из научных проектов, использованных для исследования,
% использовали матрицы !numpy.array! проекта
% Numpy\footnote{\url{http://www.numpy.org/}}. Эта библиотека не была установлена
% автоматически и для некоторых из параметров, класс для которых подбирался по
% единственному параметру !__getitem__! (подраздел~\ref{sub:sound-incomplete}), во
% множество результатов соответствующий класс не попал

Часть таких случаев, встретившихся нам при ручном анализе выведенных типов, была
связана с особенностью работы модуля стандартной библиотеки !argparse!,
предназначенного для разбора аргументов командной строки.
Этот модуль, а также ранее упоминавшийся модуль !optparse! возвращают результаты
разбора в виде специальных объектов !argparse.Namespace! и !optparse.Values!,
имеющиеся атрибуты которых зависят от конкретных опций командной строки,
заданных пользователем. Пример использования !argparse! приведен в
листинге~\ref{lst:argparse-sample}.

\begin{lstlisting}[
    caption={Пример использовани модуля \texttt{argparse}},
    label={lst:argparse-sample}
]
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--fizz', action='store_true')
args = parser.parse_args()

def func(args):
    if args.fizz: # user-defined attribute
        print('Buzz')

func(args)
\end{lstlisting}

Очевидно, что атрибут !fizz! не объявлен непосредственно в классе
!argparse.Namespace!, и поэтому этот класс не может быть найден в качестве типа
параметра !args! функции !func!, из-за чего последний может оказаться как в
группе параметров с атрибутами, но без выведенных типов, так и среди параметров
с типами выведенными неверно. Среди рассмотренных нами параметров функций
неверно выведенные по этой причине типы встретились три раза --- все в проекте
minos\footnote{\url{https://github.com/XiaoMi/minos}}. В
листинге~\ref{lst:minos-get_service_config} приведен один из этих случаев ---
функция !get_service_config!.

\begin{lstlisting}[
  caption={Пример неверно выведенного типа для параметра типа
    \texttt{argparse.Namespace}},
  label={lst:minos-get_service_config}
]
def get_service_config(args):
  '''
  Get service config, without any dependencies.

  @param  args       the command line arguments object parsed by argparse
  '''
  service_config.get_short_user_name(args)
  if not getattr(args, args.service + "_config", None):
      setattr(args, args.service+"_config", ServiceConfig(args))
  return getattr(args, args.service+"_config")
    
\end{lstlisting}

Все три раза происходило обращение к атрибуту !service! параметра !args!, и
каждый раз из-за этого был неверно выведен тип !SupervisorClient!. Мы
ничего не можем сделать в таких случаях, потому что здесь идет речь об атрибутах
конкретного объекта в программе, которые наш алгоритм никак не учитывает.

Другим интересным примером неверно выведенного типа параметра является метод
!CodeGenerator.visit_Slice! проекта
Jinja2\footnote{\url{https://github.com/mitsuhiko/jinja2}}. Для его параметра !node!
ошибочно выводится стандартный класс !builtins.slice!, тогда как на самом деле
его тип --- !jinja2.nodes.Slice!. Нужный класс оказывается не найден, потому что атрибуты
!start!, !stop! и !step!, к которым происходит обращение, объявлены через
атрибут !field! класса !Slice! (листинг~\ref{lst:jinja2-Slice}) и инициализируются в
конструкторе суперкласса !Node! посредством вызова !setattr!, что, очевидно, не
учитывается при поиске атрибутов класса в процессе индексации. 

\begin{lstlisting}[
  caption={Фрагмент определения класса \texttt{jinja2.nodes.Slice}},
  label={lst:jinja2-Slice}
]
class Slice(Expr):

    fields = ('start', 'stop', 'step')
    ...

\end{lstlisting}

Будет справедливо отметить однако, что класс !Slice! описывает один из узлов
AST, которое используется в проекте Jinja2, и такой способ позволяет избежать
необходимости создавать большое число однотипных конструкторов, инициализирующих
атрибуты объекта.

Подводя итог, мы не можем совсем исключить неточность при анализе в случае
использования подобных возможностей, характерных для Python и других динамически
типизированных языков, однако считаем, что на практике их использование в
реальных проектах остается сравнительно небольшим.

\section{Использование метода для автодополнения}
\label{sec:autocompletion-usage}

Мы рассмотрели характеристики эффективности, а также различные виды
ошибок в контексте использования предлагаемого метода в качестве средства для
поиска программных дефектов. Тем не менее выводимые с его помощью типы можно
использовать в среде разработки и в других целях, например, для такой функции,
как автодополнение.
Причем нахождение в процессе вывода лишних классов, приводившее ранее к падению
полноты, не оказывает негативного влияния на качество автодополнения.
Действительно, если в было выведено несколько типов, то каждое добавление
нового атрибута параметра пользователем, будет уменьшать это
множество, делая предлагаемые типы все более точными.  Поясним идею на
примере. Допустим, в проекте имеется функция, приведенная в
листинге~\ref{lst:autocompletion-sample-1}. 

\begin{lstlisting}[
  caption={Пример автодополнения по результатам вывода},
  label={lst:autocompletion-sample-1}
]
def func(x):
    y = x.pop()
    x. # autocompetion
\end{lstlisting}

Пользователь использует автодополнение на параметре !x! в последней строке.
Несколько стандартных классов имеют метод !pop!, среди них !set!, !list! и
!dict!. Атрибуты каждого из них предлагаются пользователю. Допустим,
пользователь выбрал метод !update!, который определен только для !dict! и
!set!. Теперь, список возможных классов уменьшился до двух: !set! и
!dict!. В третий раз он выбирает метод !items!, который есть только у класса
!dict!.  Далее ему предлагаются только методы, которые имеются только у !dict!,
так как во множестве возможных классов останется только эта коллекция.

% Profit! 

\newpage

\section{Оценка производительности}
\label{sec:performance-evaluation}

Для проанализированных проектов мы также собирали определенную статистику,
касающуюся быстродействия нашего метода и алгоритма подбора классов, описанного
в разделе~\ref{sec:algorithm-design}, в частности. Замеряемые в процессе работы
алгоритма подбора классов значения приведены в таблице~\ref{tab:performance-metrics}.

\begin{table}[H]
  \small
  \centering
  \caption{Метрики использования алгоритма подбора классов}
  \label{tab:performance-metrics}
    \begin{tabularx}{\textwidth}{|X|c|}
      \hline
      Максимальное число базовых классов & 13
      \\ \hline
      Максимальное число классов, выбранных из индекса для одного параметра & 671
      \\ \hline
      Среднее число классов, выбранных из индекса для одного параметра & 54
      \\ \hline
    \end{tabularx}
\end{table}

Значение 671 было получено для функции !takes_one_arg! в проекте
Pyramid\footnote{\url{https://github.com/Pylons/pyramid}} для
параметра !callee!, единственным использованным атрибутом которого был
метод !__init__!, ожидаемо определенный у большого числа классов.

Для трех больших проектов: Django\footnote{\url{https://github.com/django/django}},
edx-platform\footnote{\url{https://github.com/edx/edx-platform}} и
reddit\footnote{\url{https://github.com/reddit/reddit}} мы также замеряли
время вывода типов всех проиндексированных параметров в проекте. Приведенные в
таблице~\ref{tab:performance-evaluation} временные значения являются средним по
итогам пяти запусков. Все измерения проводились на компьютере со следующими 
характеристиками: CPU Intel Core i7-4770, RAM DDR3 1600 Mhz 16 Gb, OS GNU/Linux
Debain 7.5 (kernel 3.2.0-4-amd64).

\begin{table}[H]
  \small
  \centering
  \caption{Время вывода типов всех параметров в проекте}
  \label{tab:performance-evaluation}
    \begin{tabularx}{\textwidth}{|X|X|X|}
      \hline
      Проект & Количество параметров & Время вывода, мс
      \\ \hline
      Django & 9457 & 668 
      \\ \hline
      edx-platform & 7937 & 462
      \\ \hline
      reddit & 6534 & 335
      \\ \hline
    \end{tabularx}
\end{table}




% Если для параметра был выведен ровно один подходящий тип, но он был найден
% неправильно, это является как ошибкой типа \emph{false positive} так и ошибкой типа
% \emph{false negative}. Причины этого такие же как и в случае с параметрами, для
% которых не было подобрано подходящего типа: для доступа к атрибуту были
% использованы метапрограммные возможности языка, либо нечувствительный к потоку
% управления алгоритм объединил вместе атрибуты, принадлежащие различным классам.
% Для примера негативного влияния нечувствительности алгоритма к потоку исполнения
% приведем пример из исходных текстов проекта
% !frosted!\footnote{\url{https://github.com/timothycrosley/frosted}}. В данном
% проекте определен метод !Checker.add_binding(node, value, report_redef)!, 
% и для его параметра !value! был выведен тип !Importation!, однако документация к
% методу, а также анализ его вызовов говорят о том, что в действительности тип
% параметра !value! --- класс !Binding!, являющийся суперклассом для
% !Importation!. Слишком специфический класс был выведен из-за обращения к
% атрибуту !fullName!, который содержится только в классе !Importation!, обращение
% к которому, однако, выполняется после явной проверки типа значения !value! через
% вызов !isinstance(value, Imporation)! (листинг~\ref{lst:frosted-add_binding}),
% которые наш алгоритм не учитывает. 

% \begin{lstlisting}[
  % caption={Фрагмент функции \texttt{add\_binding}},
  % label={lst:frosted-add_binding}
% ]
% def add_binding(self, node, value, report_redef=True):
    % redefinedWhileUnused = False
    % if not isinstance(self.scope, ClassScope):
        % for scope in self.scope_stack[::-1]:
            % existing = scope.get(value.name)
            % if (isinstance(existing, Importation)
                    % and not existing.used
                    % and (not isinstance(value, Importation) or
                         % value.fullName == existing.fullName)
                    % and report_redef
                    % and not self.different_forks(node, existing.source)):
                % ...
    
% \end{lstlisting}

% Другим примером неверно выведенного типа аргумента является метод
% !CodeGenerator.visit_Slice(self, node)! проекта
% Jinja2\footnote{\url{http://jinja.pocoo.org/}}. Для параметра !node!
% ошибочно выводится стандартный класс !builtins.slice!, тогда как на самом деле
% его тип --- !jinja2.nodes.Slice!. Нужный класс оказывается не найден, потому что атрибуты
% !start!, !stop! и !step!, к которым происходит обращение, объявлены через кортеж
% в теле класса (листинг~\ref{lst:jinja2-Slice}) или инициализируются в
% конструкторе его суперкласса --- !Node! --- посредством вызова !setattr!, что не
% учитывается при поиске атрибутов класса в процессе индексации.

% \begin{lstlisting}[
  % caption={Фрагмент определения класса \texttt{jinja2.nodes.Slice}},
  % label={lst:jinja2-Slice}
% ]
% class Slice(Expr):

    % fields = ('start', 'stop', 'step')
    % ...

% \end{lstlisting}

% \subsection{Параметры с несколькими выведенными типами}
% \label{sub:scattered-type-parameters}

% Наконец, последнюю группу результатов вывода представляют параметры с
% несколькими выведенными типами. Первое, что здесь следует отметить, это то, что
% нахождение нескольких типов не всегда указывает на ошибку вывода. Так, например,
% в стандартной библиотеке Python, метод !upper! определен в классах !str! и
% !bytes!, и часто предполагается, что функции могут работать с двумя этими
% типами. С другой стороны, если единственным используемым атрибутом параметра
% является специальный метод !__getattr__!, что свидетельствует об обращении к
% объекту через оператор индексации (квадратные скобки), при анализе только
% стандартной библиотеки для него будут предложено больше десятка возможных
% классов (21 для Python 2.7, 11 для Python 3.4) и 60, например, для проекта
% Django\footnote{\url{https://www.djangoproject.com/}}, что, очевидно,
% свидетельствует о большом числе ложных срабатываний. 

% Как уменьшить число некорректных классов, предлагаемых в результате анализа? 
% Одним из возможных путей решения этой проблемы является оставление во множестве
% предлагаемых классов только тех, которые видимы в месте определения функции или
% метода, то есть, например, были явно импортированы или являются встроенными в
% интерпретатор и потому, видимыми всегда, например, стандартные коллекции.
% С другой стороны, это серьезно ограничивает применимость метода, например, для
% функций обратного вызова (\emph{callback}). Например, в Django в
% пользовательские функции, отвечающие за обработку HTTP запроса, передается в
% качестве первого аргумента объект класса
% !django.http.request.HttpRequest!. Поскольку момент получения запроса, а значит
% и вызова функции пользователь не контролирует (такой подход называется
% \emph{inversion of control}), создавать объект !HttpRequest! ему не приходится
% и поэтому модуль, где он определен, не включается. Сейчас тип этого параметра
% успешно выводится, но если следовать предложенному способу уменьшения числа
% предлагаемых классов, единственный верный класс окажется не включенным в
% результаты.

% В целом, фильтрация предлагаемых классов является интересной задачей, которую
% предполагается решить в ходе развития прототипа и интеграции предложенного
% метода в PyCharm.

% \subsection{Точность статического анализа}
% \label{sub:static-analysis-precision}

% Требование точности как характеристики статического анализа в среде разработки,
% частью которого является процесс вывода типов, обсуждалось в
% разделе~\ref{sec:precision-requirement}. Напомним, что данное свойство
% заключалось в том, что производимый анализ не должен приводить к ложным
% сообщениями об ошибках. Для того, чтобы ответить на вопрос, соответствует ли
% предложенный подход данному требованию, рассмотрим, какие ошибки можно найти с
% его помощью. 

% \begin{description} 

% \item[Аргумент, не совместимый со структурным типом параметра] \hfill \\ 
  % Первое, что следует заметить, такая проверка не требует разрешения
  % номинальных типов, то есть существование параметров, у которых имеются
  % атрибуты, к которым происходит обращение, но для которых не было найдено
  % подходящих классов (подраздел~\ref{sub:undefined-type-parameters}), не должно повлиять на результаты
  % проверки конкретного вызова на наличие ошибки. Однако в текущем виде, из-за
  % нечувствительности к потоку исполнения, анализ может привести к ложным
  % сообщениям об ошибке и, следовательно, не является точным. Рассмотрим пример в
  % листинге~\ref{lst:false-error-1}. 

  % \begin{lstlisting}[
    % caption={Случай ложного сообщения об ошибке},
    % label={lst:false-error-1}
  % ]

 % def func(x):
    % if isinstance(x, list):
        % x.sort()
    % elif isinstance(x, str):
        % return x.lower()

% func('foo')     
  % \end{lstlisting}
    
  % Не учитывая поток управления, алгоритм выведет тип параметра !x! $\{ sort,
  % lower \}$. Однако в стандартной библиотеке Python нет класса, у которого
  % имеются оба этих метода, и передача в функцию, например, строки приведет к сообщению об
  % отсутствии у передаваемого значения необходимого атрибута !sort!. Решением
  % этой проблемы, которое, однако, ввиду сложности его использования с модулем
  % !ast! не было добавлено в прототип, является использование в процессе вывода
  % типов только атрибутов, доступ к которым происходит \emph{на всех возможных путях
  % потока управления} в теле функции. Однако это осуществимо в составе среды
  % PyCharm.

% \item[Отсутствие класса, совместимого со структурным типом параметра] \hfill \\
  % В разделе~\ref{sub:undefined-type-parameters} были описаны ошибки типа
  % \emph{false negative}, встретившиеся в реальных проектах, когда для параметра
  % не был найден подходящий тип из-за использования динамических возможностей
  % языка для задания атрибутов классов. Ни один
  % статический анализ не позволит абсолютно точно найти все атрибуты классов,
  % определенные одним из этих способов. Например, в
  % листинге~\ref{lst:undetectable-attribute} в конструкторе класса инициализируется
  % атрибут его экземпляра, имя которого вводит пользователь.

  % \begin{lstlisting}[
    % caption={Атрибут класса, имя которого невозможно определить статически},
    % label={lst:undetectable-attribute}
  % ]
% class MyClass:
    % def __init__(self):
        % setattr(self, input(), 42)
      
  % \end{lstlisting} Это конечно патологический случай, который вряд ли
  % использовался когда-либо в реальных программах, написанных на Python, но
  % нетрудно предложить множество других примеров, где статически установить
  % наличие у класса определенного атрибута окажется невозможным
  % (\emph{infeasible}).  Однако, принимая во внимание частоту использования
  % подобных возможностей~\cite{Holkner2009} в языке, мы не можем не учитывать
  % потенциальные неточности вывода, к которым они приводят. Это значит, что
  % анализ с целью поиска подобной ошибки всегда будет вынужденно неточным.

% \end{description}


% \section{Быстродействием \label{sec:inference-performance}
