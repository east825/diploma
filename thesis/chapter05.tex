%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Анализ результатов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Собираемая статистика}
\label{sec:statistics-collecting}

Одной из задач, ставившихся при разработке прототипа, была оценка эффективности
предлагаемого метода для вывода типов параметров функций. Для этого в процессе
индексации и подбора классов по структурным типам собралась следующая
статистика:

\begin{enumerate}
  \item Количество проиндексированных модулей ($N_m$), классов ($N_c$), функций
    ($N_f$) и параметров ($N_p$) только в проекте (без зависимостей и
    стандартной библиотеки) и вместе с ними.

  \item Параметры функций, содержащие максимальное число уникальных атрибутов, к
    которым происходило обращение.

  \item Число параметров функций, к атрибутам которых не происходило обращений в
    теле функции (\emph{attributeless parameters}) --- $N_{ap}$.
    Поскольку для параметров без использованных атрибутов наш алгоритм,
    очевидно, не может подобрать каких-либо классов, для этих параметров также
    собиралась дополнительная информация:
    
    \begin{enumerate}
        \item сколько из них используются в качестве аргументов функций
        \item сколько из них используются с арифметическими и битовыми операторами
        \item сколько из них используются в качестве возвращаемого значения функции
    \end{enumerate}

  \item Число параметров функций, к атрибутам которых происходило обращение, но для
    которых не было найдено ни одного подходящего класса (\emph{undefined
      parameters}) --- $N_{up}$.

  \item Число параметров функций, к атрибутам которых происходило обращение, и для
    которых был найден только один подходящий класс (\emph{exact type parameters}) 
    --- $N_{etp}$.

  \item Число параметров функций, к атрибутам которых происходило обращение, и для
    которых было найдено более одного подходящего класса (\emph{scattered type
      parameters}) --- $N_{stp}$.

\end{enumerate}

Все четыре последние группы параметров для чистоты измерений включают только параметры функций,
входящих в проект. Для каждой из них также измерялось отношение числа входящих в
нее параметров к общему числу параметров в проекте. Обозначим эти значения как $R_{ap} =
\frac{N_{ap}}{N_p}$, $R_{up} = \frac{N_{up}}{N_p}$ и т.д.

Значения снятых метрик для нескольких из проанализированных проектов приведены в
таблице~\ref{tab:statistic-results-1}.

\begin{table}[H]
  \small
  \caption{Результаты анализа нескольких открытых проектов}
  \label{tab:statistic-results-1}
  \begin{tabularx}{\textwidth}{ |X|X|X|X|X|X|X|X| }
    \hline
    \multicolumn{1}{|c|}{\multirow{2}{*}{}} &
    \multicolumn{3}{c|}{Определения} &
    \multicolumn{4}{c|}{Параметры}
    \\ \cline{2-8}
    & $N_c$ & $N_f$ & $N_p$ & $R_{ap}$ & $R_{up}$ & $R_{etp}$ & $R_{stp}$ 
    \\ \hline

    Flask & 106 & 961 & 615 & 81.63\% & 1.14\% & 5.20\% & 12.03\%
    \\ \hline

    Django & 1696 & 7494 & 9530 & 77.81\% & 1.95\% & 5.66\% & 14.59\%
    \\ \hline

    requests & 121 & 643 & 661 & 81.09\% & 1.66\% & 2.72\% & 14.52\%
    \\ \hline

    youtube-dl & 420 & 1071 & 1201 & 83.51\% & 1.00\% & 1.17\% & 14.32\%
    \\ \hline

    fn.py & 42 & 327 & 242 & 92.56\% & 0.83\% & 3.37\% & 2.89\%
    \\ \hline

    % Flask & 106 & 961 & 615 & 502 (81.63\%) & 7 (1.14\%) & 32 (5.20\%) & 74 (12.03\%)
    % \\ \hline

    % Django & 1696/7494/9530 & 7415 (77.81\%) & 186 (1.95\%) & 539 (5.66\%) &
    % 1390 (14.59\%)
    % \\ \hline

    % requests & 121/643/661 & 536 (81.09\%) & 11 (1.66\%) & 18 (2.72\%) & 96
    % (14.52\%)
    % \\ \hline

    % youtube-dl & 420/1071/1201 & 1003 (83.51\%) & 12 (1.00\%) & 14 (1.17\%)
    % & 172 (14.32\%)
    % \\ \hline

    % fn.py & 42/327/242 &  224 (92.56\%) & 2 (0.83\%) & 9 (3.37\%) & 7
    % (2.89\%)
    % \\ \hline

  \end{tabularx}
\end{table}

Отметим, что число параметров функций может быть меньше количества функций,
потому что, во-первых, часть функций не имеет параметров, а, во-вторых, первый
параметр !self! для методов исключался из рассмотрения.

Так как отношение размеров групп параметров относительно их общего имело
особый интерес, мы также оценивали средние значения этих величин среди
проанализированных проектов: $\bar{R}_{ap}$, $\bar{R}_{up}$, $\bar{R}_{etp}$ и
$\bar{R}_{stp}$. Для этого с хостинга Github было загружено 100 проектов на
Python с открытыми исходными текстами размером не более 30 Кб. Из них были исключены
проекты, содержащие малое число модулей на Python, имеющие большое число
зависимостей или сложную структуру, препятствующую их анализу в автоматическом
режиме. Средние значения, полученные для оставшихся 66 проектов приведены в
таблице~\ref{tab:statistics-results-2}.

\begin{table}[H]
  \small
  \caption{Средние значения размеров групп параметров (в процентах) по проектам}
  \label{tab:statistics-results-2}
  \begin{tabularx}{\textwidth}{ |X|X|X| }
    \hline
    & Мат. ожидание & Ср. кв. отклонение 
    \\ \hline

    $\bar{R}_{ap}$ & 80.76\% & 8.16\% 
    \\ \hline

    $\bar{R}_{up}$ & 3.24\% & 6.27\% 
    \\ \hline

    $\bar{R}_{etp}$ & 3.58\% & 2.82\%
    \\ \hline

    $\bar{R}_{stp}$ & 12.40\% & 2.24\% 
    \\ \hline

  \end{tabularx}
\end{table}

В разделе~\ref{sec:precision-requirement} обсуждались характеристики точности
(soundness) и полноты (completeness) статического анализа, а также ставилось
требование достижения наибольшей точности при по возможности наибольшей полноте
для используемых в составе IDE методов анализа программ. Поскольку оценки
полноты и точности рассчитываются через количество ложноположительных
(false-positive) и ложноотрицательных (false-negative) программных дефектов,
полученных в результате анализа, поясним сначала, какие ошибки, могут быть найдены
нашим методом.

Так как предлагаемый в работе алгоритм позволяет находить точные типы параметров
функций в программах на Python, потенциально он позволяет предотвратить ошибку
использования аргумента неправильного типа. Следовательно, если нашим
методом будут выведены такие типы для параметра, из-за которых будет считаться
ошибкой передача в функцию правильных аргументов, пострадает точность, если же,
наоборот, мы пропустим передачу аргументов неправльного типа, пострадает
полнота.

Первые две группы параметров ($N_{ap}$ и $N_{up}$, для которых мы не смогли
вывести ни одного типа, позволяют нам оценить верхнюю границу значения полноты
анализа. Действительно, пусть типом всех параметров, для которых мы не подобрали
ни одного типа, считается !object!. Это не может привести к ложным сообщениям об
ошибках, потому что в Python любое значение, в том числе целые числа и
логические константы, считается экземпляром !object!. Однако каждый такой случай
уменьшает полноту анализа, так как исключает возможность предотвратить
потенциальный программный дефект. 

\[
  Completeness \le 1 - (\bar{R}_{ap} + \bar{R}_{up}) = \bar{R}_{etp} +
  \bar{R}_{stp} = 0.032 + 0.124 \approx 15.6\%
\]

Это значение полноты относительно всех параметров, для которых выводились типы
нашим методом, т.е. без первого параметра методов, не аннотированных как
!@staticmethod!. Можно также рассчитать значение полноты по средним значениям
относительно \emph{всех} параметров в проекте.

\[
  Completeness_{all~parameters} \le \bar{R'}_{etp} + \bar{R'}_{stp} = 0.02 + 0.082 \approx 10.3\% 
\]

Такое низкое значение полноты анализа относительно всех параметров является
допустимым, так как для всех исключенных параметров (в среднем 35\% от общего
числа), а также для ряда других PyCharm может вывести точные типы без нашего
алгоритма.

Также приведем значение полноты относительно всех выражений в проектах. Это
приближенное значение, потому что без чувствительного к потоку исполнения
алгоритма нельзя точно подсчитать число чтений значений параметров в
теле функции.

\[
  Completeness_{all~expressions} \le \bar{R''}_{etp} + \bar{R''}_{stp} = 0.002
  + 0.008 \approx 1\% 
\]

Следует отметить, что данные оценки не учитывают наличия функций, для которых
тип параметра !object! является верным, т.е. для методов, которые могут
принимать аргументы произвольного типа (например, стандартная функция !str!). Мы
считаем, однако, что доля таких функций в действительности пренебрежимо мала, в
частности нам их не встретилось при ручной оценке характеристик метода,
описанной в главе~\ref{sec:precise-analysis}.

Для оценки точности анализа, а также для уточнения значения полноты
потребовалось оценивать выведенные типы вручную. Результаты такого анализа приведены в
следующем разделе~\ref{sec:precise-analysis}.

\section{Оценка характеристик алгоритма}
\label{sec:precise-analysis}

На практике существует четыре возможных результата вывода типов для параметра,
которые по-разному влияют на точность и полноту анализа.

\begin{description}

  \item[Точные и полные результаты] \hfill \\
    Если в результате вывода типа параметра был найден один или несколько
    классов, каждый из которых является правильным, такой результат считается и
    точным, и полным.
    
  \item[Точные, но неполные результаты] \hfill \\
    Если в результате вывода типов было найдено несколько классов, только часть
    из которых является правильными, или был выведен более общий тип
    (суперкласс), чем нужно, то такой результат не уменьшит точности анализа,
    однако негативно скажется на его полноте, потому что появится возможность
    пропустить ошибку передачи в функцию неправильного аргумента.

  \item[Неточные, но полные результаты] \hfill \\
    Такой случай возможен, если для параметра было выведено меньше подходящих
    классов, чем возможно на самом деле, или, если был выведен более частный тип
    (подкласс). Сразу отметим, что таких ситуаций среди рассмотренных было
    меньше всего.

  \item[Неточные и неполные результаты] \hfill \\
    Такой вариант имеет место, если все классы, подобранные для параметра, один
    или несколько, являются неверными.

\end{description}

Для оценки полноты анализа мы случайным образом выбрали 100 параметров функций
рассмотренных проектов, для которых было выведено один или несколько типов, и,
вручную оценив корректность выведенных типов, сгруппировали их по четырем
приведенным категориям. Полученные результаты приведены в
таблице~\ref{tab:manual-analysis-results}.

\begin{table}[H]
  \small
  \caption{Результаты ручной оценки качества вывода типов}
  \label{tab:manual-analysis-results}
    \begin{tabularx}{\textwidth}{|X|X|}
      \hline
      Тип результата & Количество случаев 
      \\ \hline 
      Точные и полные & 40
      \\ \hline
      Точные и неполные & 42 
      \\ \hline
      Неточные и полные & 2
      \\ \hline
      Неточные и неполные & 16
      \\ \hline
    \end{tabularx}
\end{table}

Таким образом, экспериментально оцененная точность анализа составляет 82\%, а
полнота --- 42\% от полученных ранее оценок. Различные случаи ошибок в каждой
из трех последних категорий рассматриваются в следующем разделе.

\section{Ошибки анализа}
\label{sec:analysis-errors}

% Первые две группы параметров: параметры без атрибутов и параметры с атрибутами,
% для которых не было подобрано подходящих классов, объединяют случаи, где тип
% параметра остался неопределенным, что позволяет нам оценить верхнюю границу
% полноты нашего метода.


% Эта оценка полноты только для вывода типов значений параметров функций. Для
% оценки полноты метода относительно всех выражений в программе необходимо
% домножить ее на среднее значение отношения числа параметров к числу выражений в
% программе.

% Низкая полнота анализа не является проблемой, потому что, напомним, предложенный
% метод разрабатывается в качестве дополнения к имеющейся функциональности среды
% PyCharm, которая покрывает значительную часть других случаев: тип параметра
% !self!, типы аргументов со значениями по-умолчанию, а также типы некоторых
% локальных переменных.

% \subsection{Оценка точности}
% \label{sub:soundness-estimate}

% Для оценки точности анализа мы использовали следующий подход. Среди параметров в
% рассмотренных проектах, попадающих в последние две группы: параметры, для
% которых был выведен только один класс, и параметры, для которых было найдено
% более одного класса, было взято 100 случайных, корректность вывода типа для
% которых была проверена вручную.



% % Как видно из приведенных результатов, даже при большом числе допущений,
% % принятых в прототипе доля параметров для которых находится по крайней мере тип
% % не так высока (15\%).  Однако следует учитывать, что в прототипе не используются
% % имеющиеся возможности по выводу типов в PyCharm, перечисленные в
% % подразделе~\ref{sec:compatibility-requirement}.  Пути повышения точности анализа
% % обсуждаются в следующем разделе~\ref{sec:inference-precision}.

% \section{Точность вывода}
% \label{sec:inference-precision-analysis}

% Возможные ошибки алгоритма вывода типов параметров можно разделить на две категории:
% \begin{description}
    % \item[Ошибки типа \emph{false positive}] выражаются в том, что для параметра
      % будут найдены неправильные классы, которые в
      % действительности не подходят для передачи в функцию и могут привести к
      % ошибке во время исполнения.

    % \item[Ошибки типа \emph{false negative}] выражаются в том, что для параметра
      % не будут найдены подходящие классы, несмотря на то, что такие классы
      % определены в проекте или библиотеках, от которых он зависит.

% \end{description}

% Рассмотрим подробнее различные источники этих ошибок.

\subsection{Параметры без обращений к атрибутам}
\label{sub:attributeless-parameters}

Самым большим ограничением полноты анализа на данный момент являются параметры
функций, к атрибутам которых не происходит обращений, которых, напомним в
среднем 82\% от всех рассмотренных параметров.

Одним из возможных решений является учет при подборе типов, так называемых,
специальных методов (\emph{special methods}). Например,
в Python и ряде других динамически типизированных языков путем переопределения
специальных методов осуществляется перегрузка операторов.  Так, в
листинге~\ref{lst:plus-overloading} приведен пример перегрузки оператора
сложения !+! для класса !TextRange!.

\begin{lstlisting}[
  caption={Пример перегрузки оператора в Python},
  label={lst:plus-overloading}
]
сlass TextRange:
    def __init__(self, x, y):
        if y < x or x < 0:
            raise ValueError('Illegal range: must be y >= x && x >= 0')
        self.x = x
        self.y = y

    def __add__(self, other):
        if not isinstance(other, TextRange):
            return NotImplemented
        return TextRange(min(self.x, other.x), max(self.y, other.y))

def union_range(r1, r2):
    return r1 + r2    

\end{lstlisting}

Для приведенного примера можно было бы вывести, что для параметров функции
!union_range!: !r1! и !r2! подходящий класс обязательно должен иметь
переопределенный метод !__add__!. 

В Python имеются и другие конструкции, использование которых подразумевает
наличие у объекта переопределенных специальных методов, например, для
использования в цикле !for! у класса объекта должен быть переопределен метод
!__iter__!. Однако не все такие случаи могут быть использованы для вывода типов
на практике. Например, пользовательский класс может переопределить поведение в,
так называемом, логическом контексте (\emph{boolean context}) через метод
!__bool__!. Если в классе данный метод не определен, используется метод
!__len__!, а если не определен и он, то любой объект принимается за истинное
значение
(!True!)\footnote{\url{https://docs.python.org/3.3/reference/datamodel.html\#object.\_\_bool\_\_}},
что часто используется для проверки того, содержит ли переменная значение
!None!. Таким образом, использование параметра в условном операторе не означает
наличие у класса перегруженного метода !__bool__!.

Собранная нами статистика показала, что в среднем 5.7\% параметров функций, к
атрибутам которых не происходит обращения, используются в качестве операндов
бинарных и арифметических операторов.

Следует отметить, что в прототипе уже сейчас учитываются некоторые специальные
методы в Python: !__getitem__!, !__setitem__! и !__delitem__!,
которые вызываются при использовании оператора взятия элемента по индексу/ключу,
например, !xs[42]! или !map['key']!, а также !__init__!, в котором определяется
конструктор класса.

Другим способом получения дополнительной информации об атрибутах является
использование информации от функций, в которые передается значение параметра в
качестве аргумента. Такой способ должен существенно повысить качество вывода, за
счет учета большего количества дополнительных атрибутов, однако связан с рядом
трудностей. В частности существует неоднозначность определения функции,
например, если вызывается метод одного из других параметров. Пример такой
неопределенности при выводе типов показан в
листинге~\ref{lst:called-function-ambiguity}.

\begin{lstlisting}[
  caption={Неопределенность при использовании информации из вызываемых
    функций},
  label={lst:called-function-ambiguity}
]
class A:
    def foo(self, x):
        x.bar()

class B:
    def foo(self, x):
        x.baz()

def func(x, y):
    x.foo(y)
\end{lstlisting}

В приведенном примере неясно, какие из атрибутов !bar! и !baz! должен содержать
структурный тип параметра !func.y!, потому что в качестве типа параметра
!func.x! подходят классы !A! и !B!. Одним из путей решения данной проблемы
является использование этого способа только в том случае, если вызываемая функция точно
известна, т.е. является, например, стандартной функцией или --- при выводе
типов параметров методов --- другим методом того же класса (вызвана на параметре
!self!). Другим возможным решением является использования пересечения множеств
атрибутов, используемых во всех возможных вариантах вызываемой функции.

Собранная статистика показывает, что в среднем 54.9\% параметров, к атрибутам
которых не происходит обращения в теле функции, передаются в другую функции.

Наконец, даже если параметр функции не был использован ни в качестве операнда,
ни в качестве аргумента, а был, например, сразу возвращен, такую функцию можно
расценивать, как параметризованную, т.е. использующую параметрический
полиморфизм. Примером, такой функции является уже приводившаяся ранее в
листинге~\ref{lst:identity-function} функция-идентичности, типом которой
является $(a) \rightarrow a$. Параметров без атрибутов, используемых в качестве
возвращаемого значения функции среди рассмотренных проектов оказалось 1.3\%.

\subsection{Параметры с неопределенным типом}
\label{sub:undefined-type-parameters}

Другую группу параметров из-за которых падает полнота анализа представляют
параметры, у которых имеются параметры, к атрибутам которых происходит
обращение, но для них не было выведено ни одного типа. Напомним, что таких
случаев среди рассмотренных проектов было в среднем 3.2\%. Анализ нескольких
таких случаев показал, что это может произойти по следующим причинам:

\begin{enumerate}
    \item Необходимый класс не был проиндексирован, например, из-за того, что
      проектная зависимость не была включена в анализ.

    \item Атрибут класса был выставлен при помощи метапрограммных средств языка,
      например, через метаклассы, функцию !setattr! или просто
      вне конструктора, что не поддерживается в прототипе, и потому этот класс не был
      найден в процессе вывода типов.

    \item Не учитывающий поток исполнения алгоритм поиска атрибутов параметра
      привел к созданию структурного типа, включающего слишком много
      атрибутов, и с которым поэтому не совместим ни один класс.

\end{enumerate}

Для иллюстрации второго случая можно привести такой пример. В проекте
pep8\footnote{\url{https://github.com/jcrocholl/pep8}} для разбора аргументов
командной строки используется стандартный модуль !optparse!, частью интерфейса
которого является класс !OptionParser!. Этот класс содержит методы, такие как
!add_option! или !parse_args!, 
предназначенные для упрощения описания и разбора аргументов командной строки
приложения. Экземпляр класса !OptionParser! передается в качестве аргумента в
несколько функций !pep8!, однако несмотря на наличие атрибутов, однозначно
идентифицирующих этот класс, для соответствующих параметров он не был выведен.
Например, в функции !pep8.process_options(arglist, parse_argv, config_file, parser)!
происходит обращение к атрибутам параметра
!parser!: !has_option!, !parse_args!, !error! и !config_options!. Первые три из
них определены непосредственно в классе !OptionParser! или в его суперклассе
!OptionContainter!, однако последний --- !config_options! --- добавляется к
экземпляру !OptionParser! вне модуля !optparse! в функции
!pep8.get_parser(prog, version)!, фрагмент которой приведен в
листинге~\ref{lst:pep8-get_parser}. Это приводит к тому, что класс
!OptionParser! не расценивается как подходящий по структуре для параметра
!parser!.

\newpage
\begin{lstlisting}[
  caption={Фрагмент функции \texttt{pep8.get\_parser}}, 
  label={lst:pep8-get_parser} 
]
def get_parser(prog='pep8', version=__version__):
    parser = OptionParser(prog=prog, version=version,
                          usage="%prog [options] input ...")
    parser.config_options = [
        'exclude', 'filename', 'select', 'ignore', 'max-line-length',
        'hang-closing', 'count', 'format', 'quiet', 'show-pep8',
        'show-source', 'statistics', 'verbose']
    ...
\end{lstlisting}

В другой функции в том же проекте --- 
!pep8.read_config(options, args, arglist, parser)!
--- для параметра !parser!
класс !OptionParser! снова не выводится: на этот раз из-за обращения к атрибуту
!options_list!, который инициализируется не в конструкторе !OptionParser!, а в
методе !_create_options_list!, вызываемом в конструкторе его суперкласса,
из-за чего он также не учитывается нашим алгоритмом.

\subsection{Параметры с единственным выведенным типом}
\label{sub:single-type-parameters}

Если для параметра был выведен ровно один подходящий тип, но он был найден
неправильно, это является как ошибкой типа \emph{false positive}, так и ошибкой типа
\emph{false negative}. Причины этого такие же как и в случае с параметрами, для
которых не было подобрано подходящего типа: для доступа к атрибуту были
использованы метапрограммные возможности языка, либо нечувствительный к потоку
управления алгоритм объединил вместе атрибуты, принадлежащие различным классам.
Для примера негативного влияния нечувствительности алгоритма к потоку исполнения
приведем пример из исходных текстов проекта
!frosted!\footnote{\url{https://github.com/timothycrosley/frosted}}. В данном
проекте определен метод !Checker.add_binding(node, value, report_redef)!, 
и для его параметра !value! был выведен тип !Importation!, однако документация к
методу, а также анализ его вызовов говорят о том, что в действительности тип
параметра !value! --- класс !Binding!, являющийся суперклассом для
!Importation!. Слишком специфический класс был выведен из-за обращения к
атрибуту !fullName!, который содержится только в классе !Importation!, обращение
к которому, однако, выполняется после явной проверки типа значения !value! через
вызов !isinstance(value, Imporation)! (листинг~\ref{lst:frosted-add_binding}),
которые наш алгоритм не учитывает. 

\begin{lstlisting}[
  caption={Фрагмент функции \texttt{add\_binding}},
  label={lst:frosted-add_binding}
]
def add_binding(self, node, value, report_redef=True):
    redefinedWhileUnused = False
    if not isinstance(self.scope, ClassScope):
        for scope in self.scope_stack[::-1]:
            existing = scope.get(value.name)
            if (isinstance(existing, Importation)
                    and not existing.used
                    and (not isinstance(value, Importation) or
                         value.fullName == existing.fullName)
                    and report_redef
                    and not self.different_forks(node, existing.source)):
                ...
    
\end{lstlisting}

Другим примером неверно выведенного типа аргумента является метод
!CodeGenerator.visit_Slice(self, node)! проекта
Jinja2\footnote{\url{http://jinja.pocoo.org/}}. Для параметра !node!
ошибочно выводится стандартный класс !builtins.slice!, тогда как на самом деле
его тип --- !jinja2.nodes.Slice!. Нужный класс оказывается не найден, потому что атрибуты
!start!, !stop! и !step!, к которым происходит обращение, объявлены через кортеж
в теле класса (листинг~\ref{lst:jinja2-Slice}) или инициализируются в
конструкторе его суперкласса --- !Node! --- посредством вызова !setattr!, что не
учитывается при поиске атрибутов класса в процессе индексации.

\begin{lstlisting}[
  caption={Фрагмент определения класса \texttt{jinja2.nodes.Slice}},
  label={lst:jinja2-Slice}
]
class Slice(Expr):

    fields = ('start', 'stop', 'step')
    ...

\end{lstlisting}

\subsection{Параметры с несколькими выведенными типами}
\label{sub:scattered-type-parameters}

Наконец, последнюю группу результатов вывода представляют параметры с
несколькими выведенными типами. Первое, что здесь следует отметить, это то, что
нахождение нескольких типов не всегда указывает на ошибку вывода. Так, например,
в стандартной библиотеке Python, метод !upper! определен в классах !str! и
!bytes!, и часто предполагается, что функции могут работать с двумя этими
типами. С другой стороны, если единственным используемым атрибутом параметра
является специальный метод !__getattr__!, что свидетельствует об обращении к
объекту через оператор индексации (квадратные скобки), при анализе только
стандартной библиотеки для него будут предложено больше десятка возможных
классов (21 для Python 2.7, 11 для Python 3.4) и 60, например, для проекта
Django\footnote{\url{https://www.djangoproject.com/}}, что, очевидно,
свидетельствует о большом числе ложных срабатываний. 

Как уменьшить число некорректных классов, предлагаемых в результате анализа? 
Одним из возможных путей решения этой проблемы является оставление во множестве
предлагаемых классов только тех, которые видимы в месте определения функции или
метода, то есть, например, были явно импортированы или являются встроенными в
интерпретатор и потому, видимыми всегда, например, стандартные коллекции.
С другой стороны, это серьезно ограничивает применимость метода, например, для
функций обратного вызова (\emph{callback}). Например, в Django в
пользовательские функции, отвечающие за обработку HTTP запроса, передается в
качестве первого аргумента объект класса
!django.http.request.HttpRequest!. Поскольку момент получения запроса, а значит
и вызова функции пользователь не контролирует (такой подход называется
\emph{inversion of control}), создавать объект !HttpRequest! ему не приходится
и поэтому модуль, где он определен, не включается. Сейчас тип этого параметра
успешно выводится, но если следовать предложенному способу уменьшения числа
предлагаемых классов, единственный верный класс окажется не включенным в
результаты.

В целом, фильтрация предлагаемых классов является интересной задачей, которую
предполагается решить в ходе развития прототипа и интеграции предложенного
метода в PyCharm.

\subsection{Точность статического анализа}
\label{sub:static-analysis-precision}

Требование точности как характеристики статического анализа в среде разработки,
частью которого является процесс вывода типов, обсуждалось в
разделе~\ref{sec:precision-requirement}. Напомним, что данное свойство
заключалось в том, что производимый анализ не должен приводить к ложным
сообщениями об ошибках. Для того, чтобы ответить на вопрос, соответствует ли
предложенный подход данному требованию, рассмотрим, какие ошибки можно найти с
его помощью. 

\begin{description} 

\item[Аргумент, не совместимый со структурным типом параметра] \hfill \\ 
  Первое, что следует заметить, такая проверка не требует разрешения
  номинальных типов, то есть существование параметров, у которых имеются
  атрибуты, к которым происходит обращение, но для которых не было найдено
  подходящих классов (подраздел~\ref{sub:undefined-type-parameters}), не должно повлиять на результаты
  проверки конкретного вызова на наличие ошибки. Однако в текущем виде, из-за
  нечувствительности к потоку исполнения, анализ может привести к ложным
  сообщениям об ошибке и, следовательно, не является точным. Рассмотрим пример в
  листинге~\ref{lst:false-error-1}. 

  \begin{lstlisting}[
    caption={Случай ложного сообщения об ошибке},
    label={lst:false-error-1}
  ]

 def func(x):
    if isinstance(x, list):
        x.sort()
    elif isinstance(x, str):
        return x.lower()

func('foo')     
  \end{lstlisting}
    
  Не учитывая поток управления, алгоритм выведет тип параметра !x! $\{ sort,
  lower \}$. Однако в стандартной библиотеке Python нет класса, у которого
  имеются оба этих метода, и передача в функцию, например, строки приведет к сообщению об
  отсутствии у передаваемого значения необходимого атрибута !sort!. Решением
  этой проблемы, которое, однако, ввиду сложности его использования с модулем
  !ast! не было добавлено в прототип, является использование в процессе вывода
  типов только атрибутов, доступ к которым происходит \emph{на всех возможных путях
  потока управления} в теле функции. Однако это осуществимо в составе среды
  PyCharm.

\item[Отсутствие класса, совместимого со структурным типом параметра] \hfill \\
  В разделе~\ref{sub:undefined-type-parameters} были описаны ошибки типа
  \emph{false negative}, встретившиеся в реальных проектах, когда для параметра
  не был найден подходящий тип из-за использования динамических возможностей
  языка для задания атрибутов классов. Ни один
  статический анализ не позволит абсолютно точно найти все атрибуты классов,
  определенные одним из этих способов. Например, в
  листинге~\ref{lst:undetectable-attribute} в конструкторе класса инициализируется
  атрибут его экземпляра, имя которого вводит пользователь.

  \begin{lstlisting}[
    caption={Атрибут класса, имя которого невозможно определить статически},
    label={lst:undetectable-attribute}
  ]
class MyClass:
    def __init__(self):
        setattr(self, input(), 42)
      
  \end{lstlisting} Это конечно патологический случай, который вряд ли
  использовался когда-либо в реальных программах, написанных на Python, но
  нетрудно предложить множество других примеров, где статически установить
  наличие у класса определенного атрибута окажется невозможным
  (\emph{infeasible}).  Однако, принимая во внимание частоту использования
  подобных возможностей~\cite{Holkner2009} в языке, мы не можем не учитывать
  потенциальные неточности вывода, к которым они приводят. Это значит, что
  анализ с целью поиска подобной ошибки всегда будет вынужденно неточным.

\end{description}

Мы рассмотрели два варианта ошибок, которые можно обнаружить при помощи
предлагаемого в данной работе подхода к выводу типов параметров функций.  В том
виде, в котором алгоритм реализован в прототипе, ни один из них, к сожалению, не
гарантирует точность анализа. Тем не менее выводимые с его помощью типы можно
использовать в среде разработки и в других целях, например, для автодополнения.
Причем для автодополнения нахождение в процессе вывода лишних классов в
действительности не оказывает негативного влияния на качество его работы.
Действительно, если в было выведено несколько типов, то каждое
добавление чтения нового атрибута посредством автодополнения пользователем,
будет уменьшать это множество, делая предлагаемые данные все более точными.
Поясним идею на примере. Допустим, в проекте имеется функция, приведенная в
листинге~\ref{lst:autocompletion-sample-1}. 

\begin{lstlisting}[
  caption={Пример автодополнения по результатам вывода},
  label={lst:autocompletion-sample-1}
]
def func(x):
    y = x.pop()
    x. # autocompetion
\end{lstlisting}

Пользователь использует автодополнение на параметре !x! в последней строке.
Несколько стандартных классов имеют метод !pop!, среди них !set!, !list! и
!dict!. Атрибуты каждого из них предлагаются пользователю. Допустим,
пользователь выбрал метод !update!, который определен только для !dict! и
!set!. Теперь, список возможных классов уменьшился до двух: !set! и
!dict!. В третий раз он выбирает метод !items!, который есть только у класса
!dict!.  Далее ему предлагаются только методы, которые имеются только у !dict!,
так как во множестве возможных классов останется только он.
% Profit! 

% \section{Быстродействием \label{sec:inference-performance}
