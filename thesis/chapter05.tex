%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В этой главе обсуждается автоматическое модульное тестирование, использовавшееся
при разработке, а также опыт использования прототипа для анализа ряда открытых
проектов.

\section{Модульное тестирование}
\label{sec:unit-testing}
Модульное тестирование прототипа осуществлялось при помощи библиотеки
pytest\footnote{\url{http://pytest.org/latest/}}.
Тестируемые функции прототипа включают в себя разрешение имен, определение в
качестве типов параметров функций пользовательских классов и типов из
стандартной библиотеки, вывод типов параметров в случае сложных иерархий
классов, форматирование и подсчет статистических данных, а также
работоспособность различных вспомогательных функций, использовавшихся в проекте
--- всего 28 тестов. 

\section{Анализ открытых проектов}
\label{sec:projects-analysis}

Примеры статистики для нескольких проанализированных проектов приведены в
таблице~\ref{tab:statistic-results-1}

\begin{table}[H]
  \scriptsize
  \caption{Результаты анализа нескольких открытых проектов.}
  \label{tab:statistic-results-1}
  \begin{tabularx}{\textwidth}{ |X|X|X|X|X|X| }
    \hline
    Проект & Общее число классов/функций/параметров & Параметры без атрибутов &
    Параметры с атрибутами, но без выведенного типа & 
    Параметры с одним выведенным типом & 
    Параметры с несколькими выведенными типами \\ \hline

    Flask & 106/961/615 & 502 (81.63\%) & 7 (1.14\%) & 32 (5.20\%) & 74 (12.03\%)
    \\ \hline

    Django & 1696/7494/9530 & 7415 (77.81\%) & 186 (1.95\%) & 539 (5.66\%) &
    1390 (14.59\%)
    \\ \hline

    requests & 121/643/661 & 536 (81.09\%) & 11 (1.66\%) & 18 (2.72\%) & 96
    (14.52\%)
    \\ \hline

    youtube-dl & 420/1071/1201 & 1003 (83.51\%) & 12 (1.00\%) & 14 (1.17\%)
    & 172 (14.32\%)
    \\ \hline

    fn.py & 42/327/242 &  224 (92.56\%) & 2 (0.83\%) & 9 (3.37\%) & 7
    (2.89\%)
    \\ \hline

  \end{tabularx}
\end{table}

Также для сбора более репрезентативной статистики такой анализ был запущен на 66
случайных проектах, загруженных с Github. Результаты приведены в
таблице~\ref{tab:statistics-results-2}

\begin{table}[H]
  \scriptsize
  \caption{Результаты анализа выборки открытых проектов.}
  \label{tab:statistics-results-2}
  \begin{tabularx}{\textwidth}{ |X|X|X| }
    \hline
    Метрика & Среднее значение & Дисперсия \\ \hline
    Доля параметров без атрибутов & 0.807 & 0.006 \\ \hline
    Доля параметров с атрибутами, но без выведенного типа & 0.040 & 0.050 \\ \hline
    Доля параметров с одним выведенным типом & 0.051 & 0.001 \\ \hline
    Доля параметров с несколькими выведенными типами & 0.100 & 0.002 \\ \hline
    Максимальное число базовых классов при выводе & 4.121 & 5.470 \\ \hline
  \end{tabularx}
\end{table}

Как видно из приведенных результатов, даже при большом числе допущений,
принятых в прототипе доля параметров для которых находится по крайней мере тип
не так высока (15\%).  Однако следует учитывать, что в прототипе не используются
имеющиеся возможности по выводу типов в PyCharm, перечисленные в
подразделе~\ref{sec:compatibility-requirement}.  Пути повышения точности анализа
обсуждаются в следующем разделе~\ref{sec:inference-precision}.

\section{Точность вывода}
\label{sec:inference-precision-analysis}

Возможные ошибки алгоритма вывода типов параметров можно разделить на две категории:
\begin{description}
    \item[Ошибки типа \emph{false positive}] выражаются в том, что для параметра
      будут найдены неправильные классы, которые в
      действительности не подходят для передачи в функцию и могут привести к
      ошибке во время исполнения.

    \item[Ошибки типа \emph{false negative}] выражаются в том, что для параметра
      не будут найдены подходящие классы, несмотря на то, что такие классы
      определены в проекте или библиотеках, от которых он зависит.

\end{description}

Рассмотрим подробнее различные источники этих ошибок.

\subsection{Параметры без обращений к атрибутам}
\label{sub:attributeless-parameters}

Одним из вариантов ошибок типа \emph{false negative}, является случай, при
котором для переменной не было выведено ни одного типа вообще. Это может
произойти в частности, потому что в функции не происходит никаких обращений к
атрибутам параметра. Как видно из результатов, приведенных в
таблице~\ref{tab:statistics-results-2}, доля таких параметров высока (около
80\%). В текущей реализации алгоритм не позволяет решить найти типы для таких
параметров, поскольку без какой-либо информации о структурном типе нельзя
подобрать подходящий номинальный. Существует несколько путей для повышения
точности анализа в этом случае, включающих как сбор дополнительной информации об
атрибутах параметра, так и совмещение предложенного алгоритма с другими видами
анализа. Рассмотрим некоторые из них.

Одним из возможных решений является учет при подборе типов, так называемых,
специальных методов (\emph{special methods}). Эти методы обычно вызываются
неявно, когда значение используется в определенном контексте. Например, в
Python и ряде других динамически типизированных языков путем переопределения
специальных методов осуществляется перегрузка операторов.  Так, в
листинге~\ref{lst:plus-overloading} приведен пример перегрузки оператора
сложения !+! для класса !TextRange!.

\begin{lstlisting}[
  caption={Пример перегрузки оператора в Python.},
  label={lst:plus-overloading}
]
сlass TextRange:
    def __init__(self, x, y):
        if y < x or x < 0:
            raise ValueError('Illegal range: must be y >= x && x >= 0')
        self.x = x
        self.y = y

    def __add__(self, other):
        if not isinstance(other, TextRange):
            return NotImplemented
        return TextRange(min(self.x, other.x), max(self.y, other.y))

def union_range(r1, r2):
    return r1 + r2    

\end{lstlisting}

Для приведенного примера можно было бы вывести, что для параметров функции
!union_range!: !r1! и !r2! подходящий класс обязательно должен иметь
переопределенный метод !__add__!. 

В Python имеются и другие конструкции, использование которых подразумевает
наличие у объекта переопределенных специальных методов, например, для
использования в цикле !for! у класса объекта должен быть переопределен метод
!__iter__!. Однако не все такие случаи могут быть использованы для вывода типов
на практике. Например, пользовательский класс может переопределить поведение в,
так называемом, логическом контексте (\emph{boolean context}) через метод
!__bool__!. Если в классе данный метод не определен, используется метод
!__len__!, а если не определен и он, то любой объект принимается за истинное
значение
(!True!)\footnote{\url{https://docs.python.org/3.3/reference/datamodel.html\#object.\_\_bool\_\_}},
что часто используется для проверки того, содержит ли переменная значение
!None!. Таким образом, использование параметра в условном операторе не означает
наличие у класса перегруженного метода !__bool__!.

Следует отметить, что в прототипе уже сейчас учитываются некоторые специальные
методы в Python: !__getitem__!, !__setitem__! и !__delitem__!,
которые вызываются при использовании оператора взятия элемента по индексу/ключу,
например, !xs[42]! или !map['key']!, а также !__init__!, в котором определяется
конструктор класса.

Другим способом получения дополнительной информации об атрибутах является
использование информации от функций, в которые передается значение параметра в
качестве аргумента. Такой способ должен существенно повысить качество вывода, за
счет сбора большого количества дополнительных атрибутов, однако связан с рядом
трудностей. В частности существует неоднозначность определения функции,
например, если вызывается метод одного из других параметров. Пример такой
неопределенности при выводе типов показан в
листинге~\ref{lst:called-function-ambiguity}.

\begin{lstlisting}[
  caption={Неопределенность при использовании информации из вызываемых
    функций.},
  label={lst:called-function-ambiguity}
]
class A:
    def foo(self, x):
        x.bar()

class B:
    def foo(self, x):
        x.baz()

def func(x, y):
    x.foo(y)
\end{lstlisting}

В приведенном примере неясно, какие из атрибутов !bar! и !baz! должен содержать
структурный тип параметра !func.y!, потому что в качестве типа параметра
!func.x! подходят классы !A! и !B!. Одним из путей решения данной проблемы
является использование этого способа только в том случае, если функция точно
определена, т.е. является, например, стандартной функцией или --- при выводе
типов параметров методов --- другим методом того же класса (вызвана на параметре
!self!).

Наконец, даже если параметр функции не был использован ни в качестве операнда,
ни в качестве аргумента, а был, например, сразу возвращен, такую функцию можно
расценивать, как параметризованную, т.е. использующую параметрический
полиморфизм. Примером, такой функции является уже приводившаяся ранее в
листинге~\ref{lst:identity-function} функция-идентичности, типом которой
является $(a) \rightarrow a$.

\subsection{Параметры с неопределенным типом}
\label{sub:undefined-type-parameters}

Другую группу ошибок типа \emph{false negative} представляют параметры, у которых
имеются атрибуты к которым происходит обращение, но для них не было выведено ни
одного типа. Анализ нескольких таких случаев показал, что это может произойти по
следующим причинам:

\begin{enumerate}
    \item Необходимый класс не был проиндексирован, например, из-за того, что
      проектная зависимость не была включена в анализ.

    \item Атрибут класса был выставлен при помощи метапрограммных средств языка,
      например, через метаклассы, функцию !setattr(obj, name, value)! или просто
      вне конструктора, что не поддерживается в прототипе, и потому этот класс не был
      найден в процессе вывода типов.

    \item Не учитывающий поток исполнения алгоритм поиска атрибутов параметра
      привел к созданию структурного типа, включающего слишком много
      атрибутов, и с которым поэтому не совместим ни один класс.

\end{enumerate}

Для иллюстрации второго случая можно привести такой пример. В проекте
pep8\footnote{\url{https://github.com/jcrocholl/pep8}} для разбора аргументов
командной строки используется стандартный модуль !optparse!, частью интерфейса
которого является класс !OptionParser!. Этот класс содержит методы, такие как
!add_option(self, *args, **kwargs)! или !parse_args(self, args=None, values=None)!, 
предназначенные для упрощения описания и разбора аргументов командной строки
приложения. Экземпляр класса !OptionParser! передается в качестве аргумента в
несколько функций !pep8!, однако несмотря на наличие атрибутов, однозначно
идентифицирующих этот класс, для соответствующих параметров он не был выведен.
Например в функции !pep8.process_options(arglist, parse_argv, config_file, parser)!
происходит обращение к атрибутам параметра
!parser!: !has_option!, !parse_args!, !error! и !config_options!. Первые три из
них определены непосредственно в классе !OptionParser! или в его суперклассе
!OptionContainter!, однако последний --- !config_options! --- добавляется к
экземпляру !OptionParser! вне модуля !optparse! в функции
!pep8.get_parser(prog='pep8', version=__version__)!, фрагмент которой приведен в
листинге~\ref{lst:pep8-get_parser}. Это приводит к тому, что класс
!OptionParser! не расценивается как подходящий по структуре для параметра
!parser!.

\begin{lstlisting}[
  caption={Фрагмент функции \texttt{pep8.get\_parser} }, 
  label={lst:pep8-get_parser} 
]
def get_parser(prog='pep8', version=__version__):
    parser = OptionParser(prog=prog, version=version,
                          usage="%prog [options] input ...")
    parser.config_options = [
        'exclude', 'filename', 'select', 'ignore', 'max-line-length',
        'hang-closing', 'count', 'format', 'quiet', 'show-pep8',
        'show-source', 'statistics', 'verbose']
    ...
\end{lstlisting}

В другой функции в том же проекте --- 
!pep8.read_config(options, args, arglist, parser)!
--- для параметра !parser!
класс !OptionParser! снова не выводится: на этот раз из-за обращения к атрибуту
!options_list!, который инициализируется не в конструкторе !OptionParser!, а в
методе !_create_options_list(self)!, вызываемом в конструкторе его суперкласса,
из-за чего он также не учитывается нашим алгоритмом.

\subsection{Параметры с единственным выведенным типом}
\label{sub:single-type-parameters}

Если для параметра был выведен ровно один подходящий тип, но он был найден
неправильно, это является как ошибкой типа \emph{false positive}, так и ошибкой типа
\emph{false negative}. Причины этого такие же как и в случае с параметрами, для
которых не было подобрано подходящего типа: для доступа к атрибуту были
использованы метапрограммные возможности языка, либо нечувствительный к потоку
управления алгоритм объединил вместе атрибуты, принадлежащие различным классам.
Для примера негативного влияния нечувствительности алгоритма к потоку исполнения
приведем пример из исходных текстов проекта
!frosted!\footnote{\url{https://github.com/timothycrosley/frosted}}. В данном
проекте определен метод !Checker.add_binding(self, node, value, report_redef)!, 
и для его параметра !value! был выведен тип !Importation!, однако документация к
методу, а также анализ его вызовов говорят о том, что в действительности тип
параметра !value! --- класс !Binding!, являющийся суперклассом для
!Importation!. Слишком специфический класс был выведен из-за обращения к
атрибуту !fullName!, который содержится только в классе !Importation!, обращение
к которому, однако, выполняется после явной проверки типа значения !value! через
вызов !isinstance(value, Imporation)! (листинг~\ref{lst:frosted-add_binding}),
которые наш алгоритм не учитывает. 

\begin{lstlisting}[
  caption={Фрагмент функции \texttt{add\_binding}},
  label={lst:frosted-add_binding}
]
def add_binding(self, node, value, report_redef=True):
    redefinedWhileUnused = False
    if not isinstance(self.scope, ClassScope):
        for scope in self.scope_stack[::-1]:
            existing = scope.get(value.name)
            if (isinstance(existing, Importation)
                    and not existing.used
                    and (not isinstance(value, Importation) or
                         value.fullName == existing.fullName)
                    and report_redef
                    and not self.different_forks(node, existing.source)):
                ...
    
\end{lstlisting}

Другим примером неверно выведенного типа аргумента является метод
!CodeGenerator.visit_Slice(self, node)! проекта
Jinja2\footnote{\url{http://jinja.pocoo.org/}}. Для параметра !node!
ошибочно выводится стандартный класс !builtins.slice!, тогда как на самом деле
его тип --- !jinja2.nodes.Slice!. Нужный класс оказывается не найден, потому что атрибуты
!start!, !stop! и !step!, к которым происходит обращение, объявлены через кортеж
в теле класса (листинг~\ref{lst:jinja2-Slice}) или инициализируются в
конструкторе его суперкласса --- !Node! --- посредством вызова !setattr!, что не
учитывается при поиске атрибутов класса в процессе индексации.

\begin{lstlisting}[
  caption={Фрагмент определения класса \texttt{jinja2.nodes.Slice}.},
  label={lst:jinja2-Slice}
]
class Slice(Expr):

    fields = ('start', 'stop', 'step')
    ...

\end{lstlisting}

\subsection{Параметры с несколькими выведенными типами}
\label{sub:scattered-type-parameters}

Наконец, последнюю группу результатов вывода представляют параметры с
несколькими выведенными типами. Первое, что здесь следует отметить, это то, что
нахождение нескольких типов не всегда указывает на ошибку вывода. Так, например,
в стандартной библиотеке Python, метод !upper! определен в классах !str! и
!bytes!, и часто предполагается, что функции могут работать с двумя этими
типами. С другой стороны, если единственным используемым атрибутом параметра
является специальный метод !__getattr__!, что свидетельствует об обращении к
объекту через оператор индексации (квадратные скобки), при анализе только
стандартной библиотеки для него будут предложено больше десятка возможных
классов (21 для Python 2.7, 11 для Python 3.4) и 60, например, для проекта
Django\footnote{\url{https://www.djangoproject.com/}}, что, очевидно,
свидетельствует о большом числе ложных срабатываний. 

Как уменьшить число некорректных классов, предлагаемых в результате анализа? 
Одним из возможных путей решения этой проблемы является оставление во множестве
предлагаемых классов только тех, которые видимы в месте определения функции или
метода, то есть, например, были явно импортированы или являются встроенными в
интерпретатор и потому, видимыми всегда, например, стандартные коллекции.
С другой стороны, это серьезно ограничивает применимость метода, например, для
функций обратного вызова (\emph{callback}). Например, в Django в
пользовательские функции, отвечающие за обработку HTTP запроса, передается в
качестве первого аргумента объект класса
!django.http.request.HttpRequest!. Поскольку момент получения запроса, а значит
и вызова функции пользователь не контролирует (такой подход называется
\emph{inversion of control}), создавать объект !HttpRequest! ему не приходится
и поэтому модуль, где он определен, не включается. Сейчас тип этого параметра
успешно выводится, но если следовать предложенному способу уменьшения числа
предлагаемых классов, единственный верный класс окажется не включенным в
результаты.

В целом, фильтрация предлагаемых классов является интересной задачей, которую
предполагается решить в ходе развития прототипа и интеграции предложенного
метода в PyCharm.

\subsection{Точность статического анализа}
\label{sub:static-analysis-precision}

Требование точности как характеристики статического анализа в среде разработки,
частью которого является процесс вывода типов, обсуждалось в
разделе~\ref{sec:precision-requirement}. Напомним, что данное свойство
заключалось в том, что производимый анализ не должен приводить к ложным
сообщениями об ошибках. Для того, чтобы ответить на вопрос, соответствует ли
предложенный подход данному требованию, рассмотрим, какие ошибки можно найти с
его помощью. 

\begin{description} 

\item[Аргумент, не совместимый со структурным типом параметра] \hfill \\ 
  Первое, что следует заметить, такая проверка не требует разрешения
  номинальных типов, то есть существование параметров, у которых имеются
  атрибуты, к которым происходит обращение, но для которых не было найдено
  подходящих классов (подраздел~\ref{sub:undefined-type-parameters}), не должно повлиять на результаты
  проверки конкретного вызова на наличие ошибки. Однако в текущем виде, из-за
  нечувствительности к потоку исполнения, анализ может привести к ложным
  сообщениям об ошибке и, следовательно, не является точным. Рассмотрим пример в
  листинге~\ref{lst:false-error-1}. 

  \begin{lstlisting}[
    caption={Случай ложного сообщения об ошибке.},
    label={lst:false-error-1}
  ]

 def func(x):
    if isinstance(x, list):
        x.sort()
    elif isinstance(x, str):
        return x.lower()

func('foo')     
  \end{lstlisting}
    
  Не учитывая поток управления, алгоритм выведет тип параметра !x! $\{ sort,
  lower \}$. Однако в стандартной библиотеке Python нет класса, у которого
  имеются оба этих метода, и передача в функцию, например, строки приведет к сообщению об
  отсутствии у передаваемого значения необходимого атрибута !sort!. Решением
  этой проблемы, которое однако в виду сложности его использования с модулем
  !ast! не было добавлено в прототип, является использование в процессе вывода
  типов только атрибутов, доступ к которым происходит \emph{на всех возможных путях
  потока управления} в теле функции. Однако это осуществимо в составе среды
  PyCharm.

\item[Отсутствие класса, совместимого со структурным типом параметра] \hfill \\
  В разделе~\ref{sub:undefined-type-parameters} были описаны ошибки типа
  \emph{false negative}, встретившиеся в реальных проектах, когда для параметра
  не был найден подходящий тип из-за использования динамических возможностей
  языка для задания атрибутов классов. Ни один
  статический анализ не позволит абсолютно точно найти все атрибуты классов,
  определенные одним из этих способов. Например, в
  листинге~\ref{lst:undetectable-attribute} в конструкторе класса инициализируется
  атрибут его экземпляра, имя которого вводит пользователь.

  \begin{lstlisting}[
    caption={Атрибут класса, имя которого невозможно определить статически.},
    label={lst:undetectable-attribute}
  ]
class MyClass:
    def __init__(self):
        setattr(self, input(), 42)
      
  \end{lstlisting} Это конечно патологический случай, который вряд ли
  использовался когда-либо в реальных программах, написанных на Python, но
  нетрудно предложить множество других примеров, где статически установить
  наличие у класса определенного атрибута окажется невозможным
  (\emph{infeasible}).  Однако, принимая во внимание частоту использования
  подобных возможностей~\cite{Holkner2009} в языке, мы не можем не учитывать
  потенциальные неточности вывода, к которым они приводят. Это значит, что
  анализ с целью поиска подобной ошибки всегда будет вынужденно неточным.

\end{description}

Мы рассмотрели два варианта ошибок, которые можно обнаружить при помощи
предлагаемого в данной работе подхода к выводу типов параметров функций.  В том
виде, в котором алгоритм реализован в прототипе, ни один из них, к сожалению, не
гарантирует точность анализа. Тем не менее выводимые с его помощью типы можно
использовать в среде разработки и в других целях, например, для автодополнения.
Причем в для автодополнения нахождение в процессе вывода лишних классов в
действительности не оказывает негативного влияния на качество его работы.
Действительно, если в было выведено несколько типов, то каждое
добавление чтения нового атрибута посредством автодополнения пользователем,
будет уменьшать это множество, делая предлагаемые данные все более точными.
Поясним идею на примере. Допустим, в проекте имеется функция, приведенная в
листинге~\ref{lst:autocompletion-sample-1}. 

\begin{lstlisting}[
  caption={Пример автодополнения по результатам вывода.},
  label={lst:autocompletion-sample-1}
]
def func(x):
    y = x.pop()
    x. # autocompetion
\end{lstlisting}

Пользователь использует автодополнение на параметре !x! в последней строке.
Несколько стандартных классов имеют метод !pop()!, среди них !set!, !list! и
!dict!. Атрибуты каждого из них предлагаются пользователю. Допустим,
пользователь выбрал метод !update()!, который определен только для !dict! и
!set!. Теперь, список возможных классов уменьшился до двух: !set! и
!dict!. В третий раз он выбирает метод !items()!, который есть только у класса
!dict!.  Далее ему предлагаются только методы, которые имеются только у !dict!,
так как во множестве возможных классов останется только он.
% Profit! 

% \section{Быстродействием \label{sec:inference-performance}
