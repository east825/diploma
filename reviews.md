Рецензии на литературу
======================

[Brett Cannon][cannon] ["Localized type inference of atomic types in Python"][1]
--------------------------------------------------------------------------------

Дипломная работа [Brett Cannon](http://www.python.org/psf/records/board/history/#brett-cannon)
на тему локального вывода стандартных типов внутри функций. Цель работы
-- повысить быстродействие интерпреторора за счет добавления нескольких новых
инструкций в байт-код, позволяющих миновать процедуру поиска атрибутов
для некотороых стандартных типов и операторов (например, `STORE_SUBSCR` для вызова
`__setitem__` на словаре). Типы выводятся только для локальных переменных
внутри функций, для задания типов аргументов вводятся аннотации в
документирющих комментариях.

Несмотря на то, что досчтичь желаемого повышения быстродействия на >= 5%
автору не удалось, работа интересна по нескольким причинам:

* Имеется небольшой обзор и сравнение использующихся алгоритмов для вывода типов:
Hindley-Milner vs. Cartesian Product. В итоге, как и в других публикациях, для
анализа используется абстракная интерпретация, названная здесь *"iterative type
analysis"*.
* Неплохо расписан процесс вывода для стандарных операторов языка:
ветвелений, циклов и блоков `try/except/finally`.
* В разделе, посвященному тестированию системы, делаются инересные выводы на
счет совместимости примененного подхода и использования ООП в рассматриваемых
проектах: в методах вместо локальных переменных часто используются атрибуты
объекта, их типы никак не аннотруются и не выводятся, и это сводит на нет всю
пользу от остального анализа.
* Данны ссылки на другие интересные проекты и публиакации *(правда довольно
старые)*. Например, на [этот][starkiller]. Стоит взглянуть.
* Также в статье в разделе "Challenges" описываются типовые проблемы,
связанные с выводом типов в Python


[Alexander Aiken][aiken], Brian R. Murphy ["Static type inference in dynamically typed language"][2]
---------------------------------------------------------------------------------------------------

В работе рассматривается алгоритм вывода типов в функциональном языке [FL][].
Также, как и в прочих работах, для вывода используется абстрактная
интерпретация. Отличием использованного решения является то, что сами типы
трактуются не как множество значений, а как *множество выражений*,
А для интерпретации используются, т.н. *type rewrite rules*.
Сделано это в частности для возможности сравнения типов функций.

Честно говоря, в силу того, что статья написана довольно сжато,
а также из-за обилия специфической математической нотации,
я не понял многие из приведенных правил для вывода.
У авторов есть другие публикации, возможно помогут разобраться в этой.


Alex Holkner, James Harland ["Evaluating the dynamic behaviour of Python applications"][3]
------------------------------------------------------------------------------------------

Работа посвящена исследованию частоты использованию использования
возможностей метапрограммирования в проектах на Python. Предпосылкой для
работы является предположение, что в большинстве программ на Python
возможности вроде добавления атрибутов объектам и классам после их создания,
модификации глобального простраства имен модуля или `exec/eval`
используются только на начальном этапе исполнения, после чего программы ведут
себя во многом идентично приложениям на статически типизированных языках и
могут быть ускорены за счет JIT-компиляции (что используется в RPython).
В работе рассматриваются 24 проекта, для сбора статистики применяется
инструментированный интрепретатор.

Хотя высказанная гипотеза о полном отсутствии использования
метапрограммирования во время работы программы не подтверждается,
проведенные измерения показывают, что 70% из исследованных программ
действительно используют их значительно меньше после этапа инициализации.

В работе также приводится классификация динамических возможностей Python:

1. *Reflection.* Получение и использование информации о программе во время ее
исполнения. К этой категории авторы относят `getattr()`,
использование модуля `inspection`, специальных имен `__file__`,
`__name__` и пр.

2. *Dynamic typing*. Отсутствие аннотаций и статического вывода типов,
все проверки на этапе исполнения. Тут все понятно.

3. *Dynamic objects*. Возможность изменения уже объявленных классов во время
исполнения, добавления/удаление/изменения атрибутов объектов. Мне привычнее
термин monkey patching.

4. *Dynamic code*. Динамическое генерация и исполнение кода программой:
использование `exec()/eval()/compile()`. Сюда же относится `__import__` и,
видимо, `importlib`.

Davine Ancona, Massimo Ancona, Antonio Cuni ["RPython: a step towards reconciling dynamically and statically typed OO languages"][4]
------------------------------------------------------------------------------------------------------------------------------------

В работе приведен обзор возможностей и некоторые детали имплементации языка RPython (**R**estricted **Python**),
являющегося ограниченным подмножеством Python с глобальным выводом типов. RPython был создан для проекта [PyPy][] и
используется в в качестве языка, на котором написан интерпретатор (Standard Interpreter) и для которого
генерируются интерпретаторы конкретных программ (JIT).

Большая часть работы посвящена архитектуре компилятора и генерации байт-кода для виртуальных машин CLI и JVM.
Подсистема вывода типов, называемая Annotator, помимо пользовательских классов с наследованием от одного родителя
как в Java или C#, оперирует рядом примитивных типов: `SomeInteger`, `SomeFloat`, `SomeBool`, `SomeChar`,
SomeString и коллекциями: `SomeTuple`, `SomeList`, `SomeDict`. Все коллекции за исключением SomeTuple -- гомогенные.
Следующий уровень компилятора -- RTyper осуществляет преобразование типов, полученных Annotator'ом, в стандартные типы
целевой платформы. RTyper в свою очередь в зависимости от того, какой back-end используется,
применяет одну из двух систем типов: lltype для LLVM и генерации программ на C и ootype для CLI, JVM и JavaScript.

В целом RPython и его система типов накладывает слишком строгие ограничения на возможности языка. Думаю,
дальше рассматривать RPython нецелесообразно.


Frédéric Pluquet, et al. ["Fast type reconstruction for dynamically typed programming languages"][5]
-------------------------------------------------------------------------------------------------

Интересная статья. Посвящена выводу типов в Smalltalk. Акцент сделан на малое время анализа
даже ценой точности результатов.

Авторы используют следующие категории алгоритмов вывода типов:

* *Whole program analysis* -- глобальный batch-анализ
* *Demand-driven analysis* -- локальный и по требованию

Быстройдействие достигается за счет того, что

1. выводятся типы только для: полей класса, локальных переменных, возвращаемых и принимаемых значений методов(!)
2. анализ происходит только **внутри одного класса**, которому принадлежит метод/поле (даже без подклассов)

Система типов опять формально никак не задается, зато подробно описан алгоритм вывода. Он состоит из трех этапов.

1. *Interface type extraction*. Для заданной переменной фиксируются все обращения к ее атрибутам.
При этом анализируются как обращения напрямую к переменной, так и к результату соответствующего метода-геттера (для
Python `property`?). После этого по иерархии всех известных классов проводится поиск в ширину с выборкой всех
подходящих. В результате получаются *Interface Types*.
2. *Assignment type extraction*. Анализируются все операторы присваивания значения данной переменной.
Для того чтобы не выводить тип выражения в правой части оператора используются следующие эвристики (*к вопросу об
источниках типов*):

    * если выражение -- вызов конструктора, берем его тип
    * если выражение -- литерал, берем его тип
    * если выражение -- логическое выражение, считаем, что тип Boolean (для Python не подойдет)
    * если выражение -- арифиметическое выражение, считаем, что тип -- Number (совсем плохо)

    В результате получаются *Assignment Types*.

3. *Merging*. Результаты объединяются с использованием нескольких эвристик для разрешения конфликтов вроде:

    * Оба этапа до этого нашли никак не связанные типы
    * Во время первого этапа был выведен более общий тип
    * Во время второго этапа был выведен более общий тип

Для вывода типов параметров функций анализируются аргументы при вызовах этого метода в рассматриваемом классе.
Для вывода типа возвращаемого значения анализируются обращения к атрибутам результата вызова внутри класса.

Для повышения точности также строится граф зависимостей между локальными переменными, полями и
возвращаемыми/принимаемыми значениями методов.

Оставшаяся часть работы посвящена анализу точности полученного решения, для чего авторы используют информацию,
собираемую во время исполнения тестовых программ. Как ни странно, несмотря на все допущения, эксперименты указывают на
75% точность результатов.

Michael Furr, et al. ["Static Type Inference for Ruby"][6]
--------------------------------------------------------

На данный момент самая подробная статья из прочитанных. Авторы разработали инструмент DRuby[], который выполняет
статический анализ программы перед передачей управления стандартному интерпретатору Ruby.

Для сбора информации о типах помимо вывода применяется язык аннотаций. Для проверки корректности аннотаций
также выполняются проверки на этапе исполнения (проверка контракта).

Система типов включает:

* *Intersection Types*. Применяются для "перегруженных" функций с необязательными аргументами, vararg'ами
или просто ведущих себя по-разному в зависимости от переданных аргументов (вроде конструктора `type` в Python).
* *Union Types*. Применяются для условных операторов, где значением переменной может стать одно из нескольких
возможных.
* *Self Type*. Специальный тип для экземпляра класса. В системе типов считается,
что он неявно передаются первым аргументом в каждый метод (horray!).
* *Object Type*. Тип объекта класса. В зависимости от вызываемых на нем методов содержит ограничения на их
типы.
* *Mixins*. Mixins (modules в Ruby) имеют отдельный тип. Это связано с тем, что они используют атрибуты объекта в них
самих не определенные, например, "spaceship" `<=>` оператор и mixin `Ordered`, генерирующий на его основе другие
методы-операторы сравнения.
* *First class methods* Также отдельный вид для методов, как объектов первого порядка. В Ruby это в первую очередь
относится к блокам.
* Стандартные примитивные типы и `Nil`. Выводятся из литералов.

Разработанная система типов не поддерживает возможности Ruby, связанные с интроспекцией и динамической
генерацией/исполнением кода.

TODO: написать больше про статью.

Alexander Aiken et al. ["Soft typing with conditional types"][7]
----------------------------------------------------------------

pass

Eva Maia et al. ["A Static Type Inference for Python"][8]
---------------------------------------------------------

Работа посвящена выводу типов для RPython. Насколько я понял, этот алгоритм не является частью проектов RPython и
PyPy, а просто ислледовательская работа на тему вывода типов для подмножества динамически типизированного языка.
Тем не менее в ней формально (в отличии от самой [статьи про RPython][4]) описана разработанная система типов и
правила вывода. Работа небольшая, есть несколько неясных моментов, но в целом может быть полезно.

Любопытно, что в статье упоминается другая работа тех же авторов, где даны более полные правила вывода типов в
разработанной ими системе, но эту работу не найти. В целом за исключением формального описания системы типов из-за
того, что целевой язык RPython со всеми присущими ему ограничениями в целом мало интересного.

Michael Salib [Faster than C: Static Type Inference with Starkiller][10]
------------------------------------------------------------------------

На эту работу приводится очень много ссылок. Автор разработал систему вывода типов для Python на основе алгоритма
Cartesian Product Algorithm (CPA), описанного в работе [[11]]. Как и в [[11]] алгоритм flow-insensitive и
глобальный, но предложено несколько путей повышения точности, например использование SSA в процессе анализа.
Кстати в оригинальной публикации говорится, что CPA эффективен для инструментов разработки,
так как изменения участка программы не приводят к необходимости повторно анализировать все исходные тексты. То есть
именно то что нужно. Основная решаемая CPA задача - вывод типов функций.

В работе описываются (опять же неформально) внесенные в CPA изменения для поддержки некоторых особенностей языка

1. Функции высшего порядка и замыкания: введение специальных узлов для определений функций в граф потока данных.
2. Наследование: описание типов классов и экземпляров классов. К конструкторам классов применяется тот же подход, что
и к функциям - множество мономорфных шаблонов для каждого вызова.
3. Исключения. Вообще никак не анализируются. Автор аргументирует, почему нельзя использовать типы исключений в блоке
`except` для вывода, но, честно говоря, я не понял его рассуждений. Возможно, проблема определения того,
какие исключения может выбрасывать метод, действительно сложна применительно к Python,
но почему не использовать ту информацию, которую предоставляет сам программист для локального анализа внутри блока
`except`?
4. Метапрограммирование с использованием `eval`/`exec`. Как и в ранее рассмотренных работах автор придерживается
точки зрения, что эти возможности либо не используют вовсе, либо, если используют, то не должны J. Тем не менее он
предлагает несколько возможных подходов для увелечения точности анализа, например, введение интерпретатора в анализатор
для получения аргументов, передваемых в эти функции, и последующей типизации их значений основным алгоритмом.

Для взаимодействия со сторонними модулями, написанными на C, также используются создаваемые пользователем аннотации,
причем не в форме специального DSL, как в других работах, а просто через API системы на C++, что конечно не слишком удобно.

Есть раздел, где обсуждается возможность вывода типов элментов коллекций. Например, если через литерал был создан
список, где известны типы отдельных элеметов, то до какого момента можно утверждать, что они не изменились.

Для сообщения об ошибках в программу подставляются явные проверки типов (!) в местах, где возможны ошибки. Вообще
вся система для вывода типов разрабатывалась с целью создания эффективного интрепретатора,
а не инструмента для статического анализа программ.

Значительная часть работы посвящена семантике языка (создание классов, перегрузка операторов, генераторы), а также
некоторым деталям имплементации, которые давно потеряли свою актуальность: например, обсуждение влияния различий между
обычными и длинными целыми типами данных, а также автоматического преобразования между ними на вывод.

Разработанная система была протестирована только на стандартной библиотеке Python 2.3.

Ole Agesen [The Cartesian Product Algorithm][11]
------------------------------------------------
TODO: написать подробнее о самом CPA и его адаптация в работах [[12]] и [[11]]

Cartesian Product Algorithm (далее CPA) был разработан для вывода типов в языке [Self][] и предназначен для
вывода *конкретных типов (concrete types)* при *параметрическом полиморфизме (parametric polymorphism)*.

### Терминология

В статье вводятся следующие определения:

*Конкретные (concrete, implementation, representation)* типы противопоставлются *абстрактным (abstract,
interface, principal)* типам. Конкретные типы описывают логику и состояние объекта,
абстрактные лишь задают набор его свойств. Например, применительно к Java конкретные типы - примитивы и обычные классы,
экзмепляры которых можно создать, а абстактные типы - интерфейсы и абстракные классы. В Python,
Self и других динамически типизированных языках абстрактными типами будут ограничения вида
"объект имеет атрибуты foo() и bar()" (ABC в Python?).

В статье приведено интересное замечание о том, что системы классов в традиционных объектно-ориентированных статически
типизированных языках, таких как C++ или Java, не являются ни полностью конкретными, ни полностью абстрактными,
так как, с одной стороны, нельзя описать совершенно произвольный тип данных, с другой,
до этапа исполнения программы конкрентый тип переменной может быть неизвестен.

>Concrete and abstract types are extremes in a spectrum of type systems. Class-types, as found in BETA,
C++, and Eiffel, are neither fully abstract (it is impossible to express the type ofanyobject that has a push
and a pop operation), nor fully concrete (declaring an object with class typeStack, does not reveal the specific
subclass of which it is an instance).

*Параметрический полиморфизм*. Противопоставляется *полиморфизму данных* (data polymorphism).
Здесь определения авторов работы расходятся с привычной мне терминологией. Для меня параметрический полиморфизм - это,
например, generic'и в Java. То есть описание семейства классов через с одинаковой логикой,
но варьирующихся по типу данных, которыми они оперируют. Другой пример параметризированные функции/типы в Haskell.
Авторы же считают, что параметрический полиморфизм - это полиморфизм функций, которые могут принимать аргументы
различных типов.
> Parametric polymorphismis the ability of routines to be invoked on arguments of several types.

Полиморфизм данных, с другой стороны, - это возможность присвоить переменной значения различных типов.
> Data polymorphismis the ability to store objects of different types in a variable or slot.

Вызов функции в работе также называется *activation record*.

### Алгоритм

В статье приводится перечень шагов, так называемого, *базового* алгоритма вывода типов:

1. Allocate type variables. Присвоение пустого множества возможных типов каждой переменной и выражению в программе.
2. Seed type variables. Инициализация системы типами которые можно вывести сразу, например, через конструкторы,
литералы и пр. (к вопросу об информации о типах).
3. Establish constraints and propagate. Строится граф зависимостей по данным,
который используется для заданий ограничений в системе и обновления информации о типах в процессе работы алгоритма.

Далее вводится понятие шаблона (template, contour) - подграфа описывающего конкретную функцию в программе.

> A template is a part of the network that the basic algorithm generated from a single method. A template
includes the type variables for local slots, formal arguments, and expressions in the method as well as the constraints
among them.

Авторы отмечают, что существующие алгоритмы при анализе полиморфных функций обладают низкой точностью,
так как пытаются вывести общие типы (например, через типы-объединения) для результата и аргументов функций. В качестве
примера приводится метод `a.max(b)`, который может принимать, например, аргументы типа `{int,
float}` (как и в Python здесь объект, на котором происходит вызов, считается за первый аргумент),
и для возвращаемого значения которого базовый алгоритм выводит тип `{int|float}`. Алгоритмы,
которые анализруют функцию лишь раз, авторы называют *моновариантными (monovariant)*, а те,
которые создают для одной функции несколько шаблонов - *поливариантными (polyvariant)*.

> An algorithm, like the basic one, that analyzes
each method once is called monovariant. The improved algorithms are all polyvariant: they may analyze
methods multiple times by creating more than one template for them.

На момент написания статьи уже существовало несколько подходов к построениею поливариантных алгоритмов:

1. Введение отдельного шаблона для *каждого* вызова функции в программе. В зависимости от того происходит ли то же
самое и для вызовов внутри конкретного шаблона функции, такие алгоритмы различают по их глубине,
и в общем называют *p-level expansion*, где p - это глубина разделения. Таким образом,
0-level expansion - это базовый моновариантный алгоритм, при 1-level expansion разделение происходит для всех
вызовов одного метода, но методы, вызываемые внутри него считаются общими, при 2-level expansion вызываемым методам также
присваиваются отдельные шаблоны, но все функции, вызываемые ими, опять считаются общими и т.д.
Естественно, что такая стратегия ведет к экспоненциальному росту числа шаблонов: в работе дается ссылка на статью,
в которой описывается, основанный на данном подходе алгоритм, которому потребовалось 10 часов (!) для вывода типа
выражения `3 + 4` в Smalltalk (из-за автоматического контроля переполнения с переходом к использованию чисел
неограниченной разрядности как в Python).
Кроме того для любого p можно найти последовательность поливариантных вызовов, для которой алгоритм будет таким же
неточным как и базовый (несколько хороших примеров, например, "телескопические" вызовы для симуляции аргументов по
умолчанию приведены в [[15]]).

2. Итеративный алгоритм. Также строятся шаблоны для каждого вызова, но при этом анализируются,
для каких вызовов эти шаблоны можно сделать
разделяемыми в случае, если вызовы имеют аргументы одинаковых типов. Для первоначального определения типов запускается
базовый алгоритм. Затем для всех вызовов с аргументами различных типов вводятся новые шаблоны,
и программа анализируется еще раз. В статье говорится, что в теории число таких итераций не должно превышать
максимальной глубины вызовов в программе, но на практике определение момента останова осложняется, например,
из-за рекурсии. Естественно это ведет к замедлению анализа примерно в N раз, где N - это число итераций, а нижняя
граница времени его работы - время работы базового алгоритма.

В CPA такое разделение происходит на основе вычисления декартова произведения множеств типов аргументов - отсюда и
название алгоритма. Шаблон строится для каждого кортежа в полученном множестве,
соответственно шаблоны всегда мономорфные, другими словами, не может быть шаблона типа `max({int, float}, int)`
При этом произведение подсчитывается лениво: каждый раз как при обнаружении нового вызова функции создается новый шаблон,
либо используется существующий.

CPA, итеративный алгоритм и алгоритм хэщ-функции (описан в [[15]]) также называются *адаптивными*,
поскольку в них дополнительные шаблоны создаются только для тех вызовов, где это необходимо.

> Adaptive type inference algorithms strive to achieve this by creating many templates when it appears necessary and
sharing templates when it seems safe.

В конце работы приводится сравнение CPA с другими алгоритмами: базовым (моновариантым) и 1/2/3/4-level expansion.
По результатам измерений CPA оказывается самым точным и быстрым из всех рассмотренных.

В работе также приведены соображения по поводу анализа переопределяемых методов в языках с наследованием,
проблемами масштабируемости алгоритма и некоторых проблем, связанных с анализом рекурсивных функций и замыканиями.

Ole Agesen [Constraint-Based Type Inference and Parametric Polymorphism][15]
----------------------------------------------------------------------------

Работа по сути является подробным введением к предыдущей публикации. Также сравниваются
конкретные/абстрактные типы, адаптивные/неадаптивные алгоритмы, параметрический полиморфизм и полиморфизм данных,
моновариантный и поливариантный анализ.
Вводится понятие шаблона как формализмов для описания алгоритмов вывода типов.

Также рассматриваются базовый, p-level expansion, итеративный и алгоритмы для вывода типов.
Приводится большее число примеров для иллюстрации ограничений существующих подходов к выводу типов в динамически
типизированных языках. Кроме того описывается еще один адаптивный алгоритм - алгоритм хэш-функции,
лишь упомянтуый в перовой работе. Он имеет меньшую точность, чем итеративный алгоритм,
поэтому его описание приводить здесь не буду.


Steve Hanov [Type Inference Using the Cartesian Product Algorithm on a Dynamically Typed Language][12]
------------------------------------------------------------------------------------------------------

Еще одна работа, где для вывода типов используется CPA. На этот раз выодятся типы в специально разработанном
исследовательском языке *zscript*.

В публикации есть несколько интересных разделов:

1. Небольшой обзор существующих алгоритмов для вывода типов и ссылки на соответствуюшие работы:
    * Rapid Type Analysis (RTA)
    * Class Hierarchy Analysis (CHA)
    * Name-based analysis
    * Lattice-based analysis

2. Для упрощения анализа программа транслируется в промежуточное представление, где
    * Все константные выражения присваиваются временным переменным
    * Все возвращаемые значения функций/атрибутов также присваиваются временным переменным, за счет чего устраняются
    цепочки из последовательных вызовов методов и/или обращений к атрибутам.

3. Для того чтобы адаптировать CPA для работы с традиционным ООП языком чтение и запись в поля объекта обрабатываются
как специальные вызовы функций.

Пользователю выведенная информация о типах представляется в виде проаннотированных исходных текстов программы.

John Aycock [Aggressive Type Inference][13]
-------------------------------------------

Еще одна работа с большим индексом цитирования. Автор задается целью написать транслятора с Python на Perl (!)
для чего ему потребовался алгоритм вывода типов в программах на Python. Разработанный подход был назван им Aggressive
Type Inference (ATI). Название отражает стремление автора достичь максимальной скорости анализа ценой его точности.
Например, из-за того, что вновь используется flow-insensitive алгоритм вывода.

Потря точности оправдывается тем, что в большинстве программ на Python - по наблюдению автора - возможности
метапрограммирования используются крайне редко. Для доказательства этого он проводит исследование, похожее на
работу [[3]]: делает выборку из существующих программ и анализирует частоту вызовов `exec`/`eval`/`__import__` и
присваиваний одной переменной значений несовместимых типов.

Christopher Anderson, et. al. [Towards Type Inference for JavaScript][14]
-------------------------------------------------------------------------



[1]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231
[2]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4450
[3]: http://dl.acm.org/citation.cfm?id=1862665
[4]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.142.1457
[5]: http://dl.acm.org/citation.cfm?id=1640145
[6]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.5525
[7]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.119.1181
[8]: http://www.dcc.fc.up.pt/~nam/publica/artigoDYLA.pdf
[10]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.95.3786
[11]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.8177
[12]: http://stevehanov.ca/cs744_type_inference_project.pdf
[13]: http://www.python.org/workshops/2000-01/proceedings/papers/aycock/aycock.pdf
[14]: http://dl.acm.org/citation.cfm?id=2144917
[15]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.352.8293

[cannon]: http://ca.linkedin.com/in/drbrettcannon
[aiken]: http://theory.stanford.edu/~aiken/publications/publications.html

[FL]: http://en.wikipedia.org/wiki/FL_(programming_language)
[Self]: http://en.wikipedia.org/wiki/Self_(programming_language)
[starkiller]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.95.3786
[PyPy]: http://pypy.org/
[DRuby]: http://www.cs.umd.edu/projects/PL/druby/