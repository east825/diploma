Рецензии на литературу
======================

[Brett Cannon][cannon] ["Localized type inference of atomic types in Python"][1]
--------------------------------------------------------------------------------

Дипломная работа [Brett Cannon](http://www.python.org/psf/records/board/history/#brett-cannon)
на тему локального вывода стандартных типов внутри функций. Цель работы
-- повысить быстродействие интерпреторора за счет добавления нескольких новых
инструкций в байт-код, позволяющих миновать процедуру поиска атрибутов
для некотороых стандартных типов и операторов (например, `STORE_SUBSCR` для вызова
`__setitem__` на словаре). Типы выводятся только для локальных переменных
внутри функций, для задания типов аргументов вводятся аннотации в
документирющих комментариях.

Несмотря на то, что досчтичь желаемого повышения быстродействия на >= 5%
автору не удалось, работа интересна по нескольким причинам:

* Имеется небольшой обзор и сравнение использующихся алгоритмов для вывода типов:
Hindley-Milner vs. Cartesian Product. В итоге, как и в других публикациях, для
анализа используется абстракная интерпретация, названная здесь *"iterative type
analysis"*.
* Неплохо расписан процесс вывода для стандарных операторов языка:
ветвелений, циклов и блоков `try/except/finally`.
* В разделе, посвященному тестированию системы, делаются инересные выводы на
счет совместимости примененного подхода и использования ООП в рассматриваемых
проектах: в методах вместо локальных переменных часто используются атрибуты
объекта, их типы никак не аннотруются и не выводятся, и это сводит на нет всю
пользу от остального анализа.
* Данны ссылки на другие интересные проекты и публиакации *(правда довольно
старые)*. Например, на [этот][starkiller]. Стоит взглянуть.
* Также в статье в разделе "Challenges" описываются типовые проблемы,
связанные с выводом типов в Python


[Alexander Aiken][aiken], Brian R. Murphy ["Static type inference in dynamically typed language"][2]
---------------------------------------------------------------------------------------------------

В работе рассматривается алгоритм вывода типов в функциональном языке [FL][].
Также, как и в прочих работах, для вывода используется абстрактная
интерпретация. Отличием использованного решения является то, что сами типы
трактуются не как множество значений, а как *множество выражений*,
А для интерпретации используются, т.н. *type rewrite rules*.
Сделано это в частности для возможности сравнения типов функций.

Честно говоря, в силу того, что статья написана довольно сжато,
а также из-за обилия специфической математической нотации,
я не понял многие из приведенных правил для вывода.
У авторов есть другие публикации, возможно помогут разобраться в этой.


Alex Holkner, James Harland ["Evaluating the dynamic behaviour of Python applications"][3]
------------------------------------------------------------------------------------------

Работа посвящена исследованию частоты использованию использования
возможностей метапрограммирования в проектах на Python. Предпосылкой для
работы является предположение, что в большинстве программ на Python
возможности вроде добавления атрибутов объектам и классам после их создания,
модификации глобального простраства имен модуля или `exec/eval`
используются только на начальном этапе исполнения, после чего программы ведут
себя во многом идентично приложениям на статически типизированных языках и
могут быть ускорены за счет JIT-компиляции (что используется в RPython).
В работе рассматриваются 24 проекта, для сбора статистики применяется
инструментированный интрепретатор.

Хотя высказанная гипотеза о полном отсутствии использования
метапрограммирования во время работы программы не подтверждается,
проведенные измерения показывают, что 70% из исследованных программ
действительно используют их значительно меньше после этапа инициализации.

В работе также приводится классификация динамических возможностей Python:

1. *Reflection.* Получение и использование информации о программе во время ее
исполнения. К этой категории авторы относят `getattr()`,
использование модуля `inspection`, специальных имен `__file__`,
`__name__` и пр.

2. *Dynamic typing*. Отсутствие аннотаций и статического вывода типов,
все проверки на этапе исполнения. Тут все понятно.

3. *Dynamic objects*. Возможность изменения уже объявленных классов во время
исполнения, добавления/удаление/изменения атрибутов объектов. Мне привычнее
термин monkey patching.

4. *Dynamic code*. Динамическое генерация и исполнение кода программой:
использование `exec()/eval()/compile()`. Сюда же относится `__import__` и,
видимо, `importlib`.

Davine Ancona, Massimo Ancona, Antonio Cuni ["RPython: a step towards reconciling dynamically and statically typed OO languages"][4]
------------------------------------------------------------------------------------------------------------------------------------

В работе приведен обзор возможностей и некоторые детали имплементации языка RPython (**R**estricted **Python**),
являющегося ограниченным подмножеством Python с глобальным выводом типов. RPython был создан для проекта [PyPy][] и
используется в в качестве языка, на котором написан интерпретатор (Standard Interpreter) и для которого
генерируются интерпретаторы конкретных программ (JIT).

Большая часть работы посвящена архитектуре компилятора и генерации байт-кода для виртуальных машин CLI и JVM.
Подсистема вывода типов, называемая Annotator, помимо пользовательских классов с наследованием от одного родителя
как в Java или C#, оперирует рядом примитивных типов: `SomeInteger`, `SomeFloat`, `SomeBool`, `SomeChar`,
SomeString и коллекциями: `SomeTuple`, `SomeList`, `SomeDict`. Все коллекции за исключением SomeTuple -- гомогенные.
Следующий уровень компилятора -- RTyper осуществляет преобразование типов, полученных Annotator'ом, в стандартные типы
целевой платформы. RTyper в свою очередь в зависимости от того, какой back-end используется,
применяет одну из двух систем типов: lltype для LLVM и генерации программ на C и ootype для CLI, JVM и JavaScript.

В целом RPython и его система типов накладывает слишком строгие ограничения на возможности языка. Думаю,
дальше рассматривать RPython нецелесообразно.


Frédéric Pluquet, et al. [Fast type reconstruction for dynamically typed programming languages][5]
-------------------------------------------------------------------------------------------------

Интересная статья. Посвящена выводу типов в Smalltalk. Акцент сделан на малое время анализа
даже ценой точности результатов.

Авторы используют следующие категории алгоритмов вывода типов:

* *Whole program analysis* -- глобальный batch-анализ
* *Demand-driven analysis* -- локальный и по требованию

Быстройдействие достигается за счет того, что

1. выводятся типы только для: полей класса, локальных переменных, возвращаемых и принимаемых значений методов(!)
2. анализ происходит только **внутри одного класса**, которому принадлежит метод/поле (даже без подклассов)

Система типов опять формально никак не задается, зато подробно описан алгоритм вывода. Он состоит из трех этапов.

1. *Interface type extraction*. Для заданной переменной фиксируются все обращения к ее атрибутам.
При этом анализируются как обращения напрямую к переменной, так и к результату соответствующего метода-геттера (для
Python `property`?). После этого по иерархии всех известных классов проводится поиск в ширину с выборкой всех
подходящих. В результате получаются *Interface Types*.
2. *Assignment type extraction*. Анализируются все операторы присваивания значения данной переменной.
Для того чтобы не выводить тип выражения в правой части оператора используются следующие эвристики (*к вопросу об
источниках типов*):

    * если выражение -- вызов конструктора, берем его тип
    * если выражение -- литерал, берем его тип
    * если выражение -- логическое выражение, считаем, что тип Boolean (для Python не подойдет)
    * если выражение -- арифиметическое выражение, считаем, что тип -- Number (совсем плохо)

    В результате получаются *Assignment Types*.

3. *Merging*. Результаты объединяются с использованием нескольких эвристик для разрешения конфликтов вроде:

    * Оба этапа до этого нашли никак не связанные типы
    * Во время первого этапа был выведен более общий тип
    * Во время второго этапа был выведен более общий тип

Для вывода типов параметров функций анализируются аргументы при вызовах этого метода в рассматриваемом классе.
Для вывода типа возвращаемого значения анализируются обращения к атрибутам результата вызова внутри класса.

Для повышения точности также строится граф зависимостей между локальными переменными, полями и
возвращаемыми/принимаемыми значениями методов.

Оставшаяся часть работы посвящена анализу точности полученного решения, для чего авторы используют информацию,
собираемую во время исполнения тестовых программ. Как ни странно, несмотря на все допущения, эксперименты указывают на
75% точность результатов.

Michael Furr, et al. [Static Type Inference for Ruby][6]
--------------------------------------------------------

На данный момент самая подробная статья из прочитанных. Авторы разработали инструмент DRuby[], который выполняет
статический анализ программы перед передачей управления стандартному интерпретатору Ruby.

Для сбора информации о типах помимо вывода применяется язык аннотаций. Для проверки корректности аннотаций
также выполняются проверки на этапе исполнения (проверка контракта).

Система типов включает:

* *Intersection Types*. Применяются для "перегруженных" функций с необязательными аргументами, vararg'ами
или просто ведущих себя по-разному в зависимости от переданных аргументов (вроде конструктора `type` в Python).
* *Union Types*. Применяются для условных операторов, где значением переменной может стать одно из нескольких
возможных.
* *Self Type*. Специальный тип для экземпляра класса. В системе типов считается,
что он неявно передаются первым аргументом в каждый метод (horray!).
* *Object Type*. Тип объекта класса. В зависимости от вызываемых на нем методов содержит ограничения на их
типы.
* *Mixins*. Mixins (modules в Ruby) имеют отдельный тип. Это связано с тем, что они используют атрибуты объекта в них
самих не определенные, например, "spaceship" `<=>` оператор и mixin `Ordered`, генерирующий на его основе другие
методы-операторы сравнения.
* *First class methods* Также отдельный вид для методов, как объектов первого порядка. В Ruby это в первую очередь
относится к блокам.
* Стандартные примитивные типы и `Nil`. Выводятся из литералов.

Разработанная система типов не поддерживает возможности Ruby, связанные с интроспекцией и динамической
генерацией/исполнением кода.

TODO: написать больше про статью.



[1]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.3231
[2]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4450
[3]: http://dl.acm.org/citation.cfm?id=1862665
[4]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.142.1457
[5]: http://dl.acm.org/citation.cfm?id=1640145

[cannon]: http://ca.linkedin.com/in/drbrettcannon
[aiken]: http://theory.stanford.edu/~aiken/publications/publications.html

[FL]: http://en.wikipedia.org/wiki/FL_(programming_language)
[starkiller]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.95.3786
[PyPy]: http://pypy.org/
[DRuby]: http://www.cs.umd.edu/projects/PL/druby/